---
title: JAVA SE 笔记
date: 2017-9-10 16:39:16
tags: java
---

\###01.01_计算机基础知识(计算机概述)(了解)

- A:什么是计算机?计算机在生活中的应用举例
  - 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。
  - 应用举例
    - 1：科学计算
    - 2、数据处理
    - 3、自动控制
    - 4、计算机辅助设计
    - 5、人工智能
    - 6、多媒体应用
    - 7、计算机网络
    - ... 
- B:什么是硬件?硬件举例
  - 计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。
  - 冯.诺依曼体系结构
  - 计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。
    - 运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。
    - 存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。
    - 输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。
- C:什么是软件?软件分类及举例
  - 计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能
  - 计算机软件按照其功能划分为系统软件与应用软件
    - 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS
    - 应用软件：office  QQ聊天  YY语言  扫雷 ###01.02_计算机基础知识(软件开发和计算机语言概述)(了解)
- A:什么是软件
  - 按照特定顺序组织的计算机数据和指令的集合
- B:什么是开发
  - 软件的制作过程
- C:什么是软件开发
  - 借助开发工具与计算机语言制作软件 
- D:什么是计算机语言
  - 人与计算机之间进行信息交流沟通的一种特殊语言
- E:计算机语言的分类
  - 机器语言：
    - 机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。
  - 汇编语言：
    - 汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。
  - 高级语言：  
    - 使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。
    - 高级语言包括C,C++,C#,JAVA ###01.03_计算机基础知识(人机交互)(了解)
- A:人机交互的两种方式
  - a:命令行方式 
    - 需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 
  - b:图形化界面方式
    - 这种方式简单直观，使用者易于接受，容易上手操作。

\###01.04_计算机基础知识(键盘功能键和快捷键)(掌握)

- A:键盘功能键
  - a:Tab
  - b:Shift
  - c:Ctrl
  - d:Alt
  - e:空格	
  - f:Enter
  - g:Window
  - h:上下左右键
  - i:PrtSc(PrintScreen)屏幕截图
- B:键盘快捷键
  - a:Ctrl+A	全选
  - b:Ctrl+C	复制
  - c:Ctrl+V	粘贴
  - d:Ctrl+X	剪切
  - e:Ctrl+Z	撤销
  - f:Ctrl+S	保存

\###01.05_计算机基础知识(如何打开DOS控制台)(掌握)

- A:xp下如何打开DOS控制台？
  - a:开始--程序--附件--命令提示符
  - b:开始--运行--cmd--回车
  - c:win+r--cmd--回车
- B:win7下如何打开DOS控制台？
  - a:开始--所有程序--附件--命令提示符
  - b:开始--搜索程序和文件--cmd--回车
  - c:win+r--cmd--回车
- C:win8下如何打开DOS控制台
  - a:鼠标左击开始--下箭头--命令提示符
  - b:鼠标右击开始--搜索--cmd--回车
  - c:鼠标右击开始--运行--cmd--回车
  - d:win+r--cmd--回车

\###01.06_计算机基础知识(常见的DOS命令讲解)

- A:d: 回车	盘符切换
- B:dir(directory):列出当前目录下的文件以及文件夹
- C:cd (change directory)改变指定目录(进入指定目录)
- D:cd.. : 退回到上一级目录
- E:cd\: 退回到根目录
- F:cls : (clear screen)清屏
- G:exit : 退出dos命令行(分割线上的需要掌握,下的了解)
- /=========================================================
- md (make directory) : 创建目录
- rd (remove directory): 删除目录
- del (delete): 删除文件,删除一堆后缀名一样的文件*.txt
- notepad 创建文件
- 删除带内容的文件夹
  - rd + /s	文件夹名称(询问是否删除)
  - rd + /q + /s 文件夹名称(直接删除)

\###01.07_Java语言基础(Java语言概述)(了解)

- A:Java语言发展史
  - 詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。
  - SUN(Stanford University Network，斯坦福大学网络公司) 
- B:Java语言版本
  - JDK 1.1.4		Sparkler	宝石				1997-09-12
  - JDK 1.1.5		Pumpkin		南瓜				1997-12-13
  - JDK 1.1.6		Abigail		阿比盖尔--女子名		1998-04-24
  - JDK 1.1.7		Brutus		布鲁图--古罗马政治家和将军	1998-09-28
  - JDK 1.1.8		Chelsea		切尔西--城市名			1999-04-08
  - J2SE 1.2		Playground	运动场				1998-12-04
  - J2SE 1.2.1		none		无				1999-03-30
  - J2SE 1.2.2		Cricket		蟋蟀				1999-07-08
  - J2SE 1.3		Kestrel		美洲红隼(sǔn)			2000-05-08
  - J2SE 1.3.1		Ladybird	瓢虫				2001-05-17
  - J2SE 1.4.0		Merlin		灰背隼				2002-02-13
  - J2SE 1.4.1		grasshopper	蚱蜢				2002-09-16
  - J2SE 1.4.2		Mantis		螳螂				2003-06-26
  - JAVASE 5.0 (1.5.0)	Tiger		老虎	
  - JAVASE 5.1 (1.5.1)	Dragonfly	蜻蜓	
  - JAVASE 6.0 (1.6.0)	Mustang		野马
  - JAVASE 7.0 (1.7.0)	Dolphin		海豚
- C:Java语言平台
  - J2SE(Java 2 Platform Standard Edition)标准版
    - 是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发
  - J2ME(Java 2 Platform Micro Edition)小型版
    - 是为开发电子消费产品和嵌入式设备提供的解决方案
  - J2EE(Java 2 Platform Enterprise Edition)企业版
    - 是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 
- D:Java语言特点
  - 简单性		
  - 解释性
  - 面向对象		
  - 高性能
  - 分布式处理	
  - 多线程
  - 健壮性		
  - 动态
  - 结构中立		
  - 安全性
  - 开源
  - 跨平台 ###01.08_Java语言基础(Java语言跨平台原理)(掌握)
- A:什么是跨平台性
- B:Java语言跨平台原理
  - 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。
- C:Java语言跨平台图解
  - write once ,run anywhere!(一处编译,到处运行) ###01.09_Java语言基础(JRE和JDK的概述)(掌握)
- A:什么是JRE
  - 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。
  - JRE:JVM+类库。 
- B:什么是JDK
  - JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。
  - 其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)等
- JDK:JRE+JAVA的开发工具。
- C:为什么JDK中包含一个JRE
  - 为什么JDK中包含一个JRE呢？
    - 开发完的程序，需要运行一下看看效果。
- D:JDK,JRE,JVM的作用和关系 ###01.10_Java语言基础(JDK的下载和安装过程图解)(了解)
- A:JDK的下载
  - a:官网 <http://www.oracle.com>
  - b:演示下载流程
- B:JDK的安装
  - a:傻瓜式安装
    - 双击安装程序，然后一路next即可(但是不建议)
  - b:安装的推荐方式
    - 安装路径不要有中文或者特殊符号如空格等。
    - 所有和开发相关的软件最好安装目录统一。
      - 举例：我的JDK安装路径
        - D:\develop\Java\jdk1.7.0_72
    - 当提示安装JRE时，可以选择不安装。建议还是安装上。
  - c:演示安装流程
    - 可以先在d盘建立一个文件夹develop
    - 然后演示安装过程
- C:验证安装是否成功
  - a:通过DOS命令，切换到JDK安装的bin目录下。
    - D:\develop\Java\jdk1.7.0_72\bin
  - b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功

\###01.11_Java语言基础(JDK安装路径下的目录解释)(了解)

- a:bin目录：该目录用于存放一些可执行程序。
  - 如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。
- b:db目录：db目录是一个小型的数据库。
  - 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。
- c:jre目录："jre"是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。
- d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。
- e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。
- f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。

\###01.12_Java语言基础(Java开发工具介绍)(了解)

- A:notepad(微软操作系统自带)
- B:Editplus/Notepad++
- C:Eclipse
- D:MyEclipse
  - 给大家简单的介绍一下这些工具，然后说说我们使用这些工具的顺序。
  - 基础班：先notepad，然后Editplus，再Eclipse。
  - 就业班：MyEclipse和Eclipse都用。

\###01.13_Java语言基础(HelloWorld案例的编写和运行)(掌握)

- A:定义类

- B:写main方法

- C:写输出语句

- D:Java程序开发运行与工作原理

- E:编译和运行程序

  class HelloWorld { 		public static void main(String[] args) { 			System.out.println("HelloWorld"); 		} 	}

\###01.14_Java语言基础(HelloWorld案例常见问题)(掌握)

- A:找不到文件(都演示一下，让学生看看出现的都是什么问题)
  - a:文件扩展名隐藏导致编译失败
  - b:文件名写错了
- B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题)
  - a:class写成Class
  - b:String写成string
  - c:System写成system
  - d:main写成mian
- C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题)
  - a:把类体的那对大括号弄掉一个
  - b:把方法体的那对大括号弄掉一个
  - c:把输出语句的那对小括号弄掉一个
- D:中英文问题(都演示一下，让学生看看出现的都是什么问题)
  - a:提示信息：错误: 非法字符: \????的格式
  - 注意：java编程中需要的基本上都是英文字符

\###01.15_Java语言基础(Java语言的书写格式(约定俗成))	(掌握)

- 1,大括号要对齐,并且成对写
- 2,左大括号前面有空格
- 3,遇到左大括号要缩进,Tab
- 4,方法和程序块之间加空行让程序看起来清晰
- 5,并排语句之间加空格,例如for语句
- 6,运算符两侧加空格

\###01.16_Java语言基础(path环境变量的作用及配置方式1)(掌握)

- A:在JDK的bin目录下开发程序容易产生的问题
  - a:如果文件过多，不方便管理
  - b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了
- B:如何解决问题呢
  - notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量
- C:配置方式
  - a:xp系统
    - 右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。
  - b:win7/win8系统
    - 右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。
- path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件

\###01.17_Java语言基础(Path环境变量的配置方式2)(掌握)

- A:先配置JAVA_HOME
- B:再修改path
- C:最后说一下path是有先后顺序关系的

\###01.18_Java语言基础(classpath环境变量的作用及其配置)(了解)

- A:为什么要配置classpath
- B:classpath配置的原理
- C:如何配置classpath
- path和classpath的区别
  - path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件
  - classpath配置的java的类文件,就是.class文件

\###01.19_Java语言基础(Editplus开发程序并编译运行)(了解)

- A:配置快捷键编译运行
- B:去除备份文件

\###01.20_Java语言基础(注释概述及其分类)(掌握)

- A:什么是注释
- B:注释的分类及讲解
  - 文档注释目前不讲，说后面讲解
- 注释的作用
  - A:解释说明程序
  - B:帮助我们调试错误

\###01.21_Java语言基础(关键字的概述和使用)(掌握)

- A:什么是关键字
  - 被Java语言赋予特定含义的单词 
- B:关键字的特点
  - 组成关键字的字母全部小写 
- C:常见关键字
  - public static void class等 
- D:关键字的注意事项
  - goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 

\###01.22_Java语言基础(标识符的概述和组成规则)(掌握)

- A:什么是标识符
  - 就是给类,接口,方法,变量等起名字时使用的字符序列 
- B:标识符的组成规则
  - 英文大小写字母
  - 数字字符
  - $和_ 
- C:标识符注意事项
  - 1,不能使用关键字
  - 2,不能数字开头 

\###01.23_Java语言基础(标识符中常见的命名规则)(了解)

- 见名知意
- A:包
  - 最好是域名倒过来,要求所有的字母小写 
- B:类或者接口
  - 如果是一个单词首字母大写
  - 如果是多个单词每个单词首字母大写(驼峰标识) 
- C:方法或者变量
  - 如果是一个单词全部小写
  - 如果是多个单词,从第二个单词首字母大写 
- D:常量
  - 如果是一个单词,所有字母大写
  - 如果是多个单词,所有的单词大写,用下划线区分每个单词 

\###01.24_day01总结

- 把今天的知识点总结一遍。

\###03.01_Java语言基础(逻辑运算符的基本用法)(掌握)

- A:逻辑运算符有哪些
  - &,|,^,!
  - &&,|| 
- B:案例演示
- 逻辑运算符的基本用法
- 注意事项：
  - a:逻辑运算符一般用于连接boolean类型的表达式或者值。
  - b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。
    - 算术表达式：a + b
    - 比较表达式：a == b(条件表达式)
- C:结论：
- &逻辑与:有false则false。
- |逻辑或:有true则true。
- ^逻辑异或:相同为false，不同为true。
- !逻辑非:非false则true，非true则false。
  - 特点：偶数个不改变本身。

\###03.02_Java语言基础(逻辑运算符&&和&的区别)(掌握)

- A:案例演示
  - &&和&的区别?
    - a:最终结果一样。
    - b:&&具有短路效果。左边是false，右边不执行。
    - &是无论左边是false还是true,右边都会执行
- B:同理||和|的区别?(学生自学)
- C:开发中常用谁?
  - &&,||,!

\###03.03_Java语言基础(位运算符的基本用法1)(了解)

- A:位运算符有哪些
  - &,|,^,~ ,>>,>>>,<<
- B:案例演示
  - 位运算符的基本用法1
  - &,|,^,~ 的用法
  - &:有0则0
  - |:有1则1
  - ^:相同则0，不同则1
  - ~:按位取反

\###03.04_Java语言基础(位异或运算符的特点及面试题)(掌握)

- A:案例演示
  - 位异或运算符的特点
  - ^的特点：一个数据对另一个数据位异或两次，该数本身不变。
- B:面试题：
  - 请自己实现两个整数变量的交换
  - 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。

\###03.05_Java语言基础(位运算符的基本用法2及面试题)(了解)

- A:案例演示 >>,>>>,<<的用法:

  - <<:左移	左边最高位丢弃，右边补齐0

  - > > :右移	最高位是0，左边补齐0;最高为是1，左边补齐1

  - > > > :无符号右移 无论最高位是0还是1，左边补齐0

  - 最有效率的算出2 * 8的结果

\###03.06_Java语言基础(三元运算符的基本用法)(掌握)

- A:三元运算符的格式
- (关系表达式) ? 表达式1 : 表达式2;
- B:三元运算符的执行流程 
- C:案例演示
  - 获取两个数中的最大值

\###03.07_Java语言基础(三元运算符的练习)(掌握)

- A:案例演示
  - 比较两个整数是否相同
- B:案例演示
  - 获取三个整数中的最大值

\###03.08_Java语言基础(键盘录入的基本格式讲解)(掌握)

- A:为什么要使用键盘录入数据
  - a:为了让程序的数据更符合开发的数据
  - b:让程序更灵活一下
- B:如何实现键盘录入呢?
  - 先照格式来。
  - a:导包
    - 格式：
      - import java.util.Scanner; 
    - 位置：
      - 在class上面。
  - b:创建键盘录入对象
    - 格式：
      - Scanner sc = new Scanner(System.in);
  - c:通过对象获取数据	
    - 格式：
      - int x = sc.nextInt();
- C:案例演示
  - 键盘录入1个整数，并输出到控制台。
  - 键盘录入2个整数，并输出到控制台。

\###03.09_Java语言基础(键盘录入的练习1)(掌握)

- A:案例演示
  - 键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果
- B:案例演示
  - 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值

\###03.10_Java语言基础(键盘录入的练习2)(掌握)

- A:案例演示
  - 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等
- B:案例演示
  - 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值

\###03.11_Java语言基础(顺序结构语句)(了解)

- A:什么是流程控制语句
  - 流程控制语句：可以控制程序的执行流程。
- B:流程控制语句的分类
  - 顺序结构
  - 选择结构
  - 循环结构
- C:执行流程：
  - 从上往下，依次执行。
- D:案例演示
  - 输出几句话看效果即可

\###03.12_Java语言基础(选择结构if语句格式1及其使用)(掌握)

- A:选择结构的分类
  - if语句
  - switch语句
- B:if语句有几种格式
  - 格式1
  - 格式2
  - 格式3
- C:if语句的格式1
- if(比较表达式) { 语句体;   	}
- D:执行流程：
  - 先计算比较表达式的值，看其返回值是true还是false。
  - 如果是true，就执行语句体；
  - 如果是false，就不执行语句体；

\###03.13_Java语言基础(选择结构if语句注意事项)(掌握)

- A:案例演示
  - a:比较表达式无论简单还是复杂，结果必须是boolean类型
  - b:if语句控制的语句体如果是一条语句，大括号可以省略；
    - 如果是多条语句，就不能省略。建议永远不要省略。
  - c:一般来说：有左大括号就没有分号，有分号就没有左大括号

\###03.14_Java语言基础(选择结构if语句格式2及其使用)(掌握)

- A:if语句的格式2
- if(比较表达式) { 语句体1;   	}else {   		语句体2;   	}
- B:执行流程：
  - 首先计算比较表达式的值，看其返回值是true还是false。
  - 如果是true，就执行语句体1；
  - 如果是false，就执行语句体2；
- C:案例演示
  - a:获取两个数据中较大的值
  - b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数
  - 注意事项：else后面是没有比较表达式的，只有if后面有。

\###03.15_Java语言基础(if语句的格式2和三元的相互转换问题)(掌握)

- A:案例演示
  - if语句和三元运算符完成同一个效果
- B:案例演示
  - if语句和三元运算符的区别
  - 三元运算符实现的，都可以采用if语句实现。反之不成立。
  - 什么时候if语句实现不能用三元改进呢?
    - 当if语句控制的操作是一个输出语句的时候就不能。
    - 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。

\###03.16_Java语言基础(选择结构if语句格式3及其使用)(掌握)

- A:if语句的格式3：
- if(比较表达式1) { 语句体1;   	}else if(比较表达式2) {   		语句体2;   	}else if(比较表达式3) {   		语句体3;   	}   	...   	else {   		语句体n+1;   	}
- B:执行流程：
  - 首先计算比较表达式1看其返回值是true还是false，
  - 如果是true，就执行语句体1，if语句结束。
  - 如果是false，接着计算比较表达式2看其返回值是true还是false，
  - 如果是true，就执行语句体2，if语句结束。
  - 如果是false，接着计算比较表达式3看其返回值是true还是false，
  - 如果都是false，就执行语句体n+1。
- C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 

\###03.17_Java语言基础(选择结构if语句格式3练习)(掌握)

- A:练习1
- 需求：键盘录入一个成绩，判断并输出成绩的等级。 90-100 优   	80-89  良   	70-79  中   	60-69  及   	0-59   差
- B:练习2
  - 需求：
    - 键盘录入x的值，计算出y的并输出。
    - x>=3	y = 2 * x + 1;
    - -1<x<3	y = 2 * x;
    - x<=-1	y = 2 * x - 1;

\###03.18_Java语言基础(选择结构if语句的嵌套使用)(掌握)

- A:案例演示
  - 需求：获取三个数据中的最大值
  - if语句的嵌套使用。

\###03.19_Java语言基础(选择结构switch语句的格式及其解释)(掌握)

- A:switch语句的格式
- switch(表达式) {     case 值1：   			语句体1;   			break;   		    case 值2：   			语句体2;   			break;   		    …   		    default：	   			语句体n+1;   			break;  }
- B:switch语句的格式解释
- C:面试题
  - byte可以作为switch的表达式吗?
  - long可以作为switch的表达式吗?
  - String可以作为switch的表达式吗?
- C:执行流程
  - 先计算表达式的值
  - 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句

\###03.20_Java语言基础(选择结构switch语句的练习)(掌握)

- A:整数(给定一个值,输出对应星期几)

\###03.21_Java语言基础(选择结构switch语句的注意事项)(掌握)

- A:案例演示
  - a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的
  - b:default可以省略吗?
    - 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。
    - 特殊情况：
      - case就可以把值固定。
      - A,B,C,D
  - c:break可以省略吗?
    - 最后一个可以省略,其他最好不要省略
    - 会出现一个现象：case穿透。
    - 最终我们建议不要省略
  - d:default一定要在最后吗?
    - 不是，可以在任意位置。但是建议在最后。
  - e:switch语句的结束条件
    - a:遇到break就结束了
    - b:执行到switch的右大括号就结束了

\###03.22_Java语言基础(选择结构switch语句练习)(掌握)

- A:看程序写结果：
- int x = 2; int y = 3;   	switch(x){   		default:   			y++;   			break;   		case 3:   			y++;   		case 4:   			y++;   	}   	System.out.println("y="+y);
- B:看程序写结果：
- int x = 2; int y = 3;   	switch(x){   		default:   			y++;   		case 3:   			y++;   		case 4:   			y++;   	}   	System.out.println("y="+y);

\###03.23_Java语言基础(选择结构if语句和switch语句的区别)(掌握)

- A:总结switch语句和if语句的各自使用场景
- switch建议判断固定值的时候用
- if建议判断区间或范围的时候用
- B:案例演示
  - 分别用switch语句和if语句实现下列需求：
    - 键盘录入月份，输出对应的季节

\###03.24_day03总结 把今天的知识点总结一遍。



\###04.01_Java语言基础(循环结构概述和for语句的格式及其使用)

- A:循环结构的分类
  - for,while,do...while 
- B:循环结构for语句的格式：
- for(初始化表达式;条件表达式;循环后的操作表达式) { 循环体;   	}
- C执行流程：
  - a:执行初始化语句
  - b:执行判断条件语句,看其返回值是true还是false
    - 如果是true，就继续执行
    - 如果是false，就结束循环
  - c:执行循环体语句;
  - d:执行循环后的操作表达式
  - e:回到B继续。
- D:案例演示
  - 在控制台输出10次"helloworld"

\###04.02_Java语言基础(循环结构for语句的练习之获取数据)

- A:案例演示
  - 需求：请在控制台输出数据1-10
  - 需求：请在控制台输出数据10-1
- B:注意事项
  - a:判断条件语句无论简单还是复杂结果是boolean类型。
  - b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。
  - c:一般来说：有左大括号就没有分号，有分号就没有左大括号

\###04.03_Java语言基础(循环结构for语句的练习之求和思想)

- A:案例演示
  - 需求：求出1-10之间数据之和
- B:学生练习
  - 需求：求出1-100之间偶数和
  - 需求：求出1-100之间奇数和

\###04.04_Java语言基础(循环结构for语句的练习之水仙花)

- A:案例演示
  - 需求：在控制台输出所有的”水仙花数”
  - 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。
  - 举例：153就是一个水仙花数。
  - 153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153

\###04.05_Java语言基础(循环结构for语句的练习之统计思想)

- A:案例演示
  - 需求：统计”水仙花数”共有多少个

\###04.06_Java语言基础(循环结构while语句的格式和基本使用)

- A:循环结构while语句的格式：

- 













  ```
  while循环的基本格式：
  ```

  ```
  while(判断条件语句) {
  ```

  ```
      循环体语句;
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  完整格式：
  ```

  ```
  
  ```

  ```
  初始化语句;
  ```

  ```
  while(判断条件语句) {
  ```

  ```
       循环体语句;
  ```

  ```
       控制条件语句;
  ```

  ```
  }
  ```

- B:执行流程：

  - a:执行初始化语句
  - b:执行判断条件语句,看其返回值是true还是false
    - 如果是true，就继续执行
    - 如果是false，就结束循环
  - c:执行循环体语句;
  - d:执行控制条件语句
  - e:回到B继续。

- C:案例演示

  - 需求：请在控制台输出数据1-10

\###04.07_Java语言基础(循环结构while语句的练习)

- A:求和思想
  - 求1-100之和
- B:统计思想
  - 统计”水仙花数”共有多少个

\###04.08_Java语言基础(循环结构do...while语句的格式和基本使用)

- A:循环结构do...while语句的格式：
- do { 循环体语句;   	}while(判断条件语句);



```

```











```
  完整格式；
  初始化语句;
  do {
    循环体语句;
    控制条件语句;
  }while(判断条件语句);
```



- B:执行流程：
  - a:执行初始化语句
  - b:执行循环体语句;
  - c:执行控制条件语句
  - d:执行判断条件语句,看其返回值是true还是false
    - 如果是true，就继续执行
    - 如果是false，就结束循环
  - e:回到b继续。
- C:案例演示
  - 需求：请在控制台输出数据1-10

\###04.09_Java语言基础(循环结构三种循环语句的区别)

- A:案例演示
  - 三种循环语句的区别:
  - do...while循环至少执行一次循环体。
  - 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。
- B:案例演示
  - for循环和while循环的区别：
    - A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 	

\###04.10_Java语言基础(循环结构注意事项之死循环)

- A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。
- B:两种最简单的死循环格式
  - while(true){...}
  - for(;;){...}

\###04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星)

- A:案例演示

  - 需求：请输出一个4行5列的星星(*)图案。

  - 如图：

    ------

  ------

  ------

  ------



  ```
  
  ```











  ```
    注意：
  ```

  ```
      System.out.println("*");和System.out.print("*");的区别
  ```

- B:结论：

  - 外循环控制行数，内循环控制列数

\###04.12_Java语言基础(循环结构循环嵌套输出正三角形)

- A:案例演示
- 需求：请输出下列的形状 *   	**

------

------

------

\###04.13_Java语言基础(循环结构九九乘法表)

- A:案例演示
  - 需求：在控制台输出九九乘法表。
- B:代码优化
- 注意： '\x' x表示任意，\是转义符号,这种做法叫转移字符。



```

```











```
  '\t'  tab键的位置
  '\r'  回车
  '\n'  换行
  '\"'
  '\''
```



\###04.14_Java语言基础(控制跳转语句break语句)

- A:break的使用场景
  - 只能在switch和循环中 

\###04.15_Java语言基础(控制跳转语句continue语句)

- A:continue的使用场景
  - 只能在循环中 

\###04.16_Java语言基础(控制跳转语句标号)

- 标号:标记某个循环对其控制
- 标号组成规则:其实就是合法的标识符

\###04.17_Java语言基础(控制调整语句练习)

- A:练习题
- for(int x=1; x<=10; x++) { if(x%3==0) {   			//在此处填写代码   		}   		System.out.println(“Java基础班”);   	}



```

```











```
  我想在控制台输出2次:“Java基础班“
  我想在控制台输出7次:“Java基础班“
  我想在控制台输出13次:“Java基础班“ 
```



\###04.18_Java语言基础(控制跳转语句return语句)

- A:return的作用
  - 返回
  - 其实它的作用不是结束循环的，而是结束方法的。
- B:案例演示
  - return和break以及continue的区别?
  - return是结束方法
  - break是跳出循环
  - continue是终止本次循环继续下次循环

\###04.19_Java语言基础(方法概述和格式说明)

- A:为什么要有方法
  - 提高代码的复用性 
- B:什么是方法
  - 完成特定功能的代码块。 
- C:方法的格式
- 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句;   		return 返回值;    	} 
- D:方法的格式说明
  - 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。
  - 返回值类型：就是功能结果的数据类型。
  - 方法名：符合命名规则即可。方便我们的调用。
  - 参数：
    - 实际参数：就是实际参与运算的。
    - 形式参数；就是方法定义上的，用于接收实际参数的。
  - 参数类型：就是参数的数据类型
  - 参数名：就是变量名
  - 方法体语句：就是完成功能的代码。
  - return：结束方法的。
  - 返回值：就是功能的结果，由return带给调用者。 

\###04.20_Java语言基础(方法之求和案例及其调用)

- A:如何写一个方法
  - 1,明确返回值类型
  - 2,明确参数列表 
- B:案例演示
  - 需求：求两个数据之和的案例
- C:方法调用图解

\###04.21_Java语言基础(方法的注意事项)

- A:方法调用(有具体返回值)
  - a:单独调用,一般来说没有意义，所以不推荐。
  - b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。
  - c:赋值调用,推荐方案。
- B:案例演示
  - a:方法不调用不执行
  - b:方法与方法是平级关系，不能嵌套定义
  - c:方法定义的时候参数之间用逗号隔开
  - d:方法调用的时候不用在传递数据类型
  - e:如果方法有明确的返回值，一定要有return带回一个值

\###04.22_Java语言基础(方法的练习)

- A:案例演示
  - 需求：键盘录入两个数据，返回两个数中的较大值
- B:案例演示
  - 需求：键盘录入两个数据，比较两个数是否相等     

\###04.23_Java语言基础(方法之输出星形及其调用)

- A:案例演示
  - 需求：根据键盘录入的行数和列数，在控制台输出星形
- B:方法调用：(无返回值,void)
  - 单独调用
  - 输出调用(错误)
  - 赋值调用(错误)

\###04.24_Java语言基础(方法的练习)

- A:案例演示
  - 需求：根据键盘录入的数据输出对应的乘法表

\###04.25_Java语言基础(方法重载概述和基本使用)

- A:方法重载概述
  - 求和案例
    - 2个整数
    - 3个整数
    - 4个整数
- B:方法重载：
  - 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。
  - 参数列表不同：
    - A:参数个数不同
    - B:参数类型不同
    - C:参数的顺序不同(算重载,但是在开发中不用)

\###04.26_Java语言基础(方法重载练习比较数据是否相等)

- A:案例演示
  - 需求：比较两个数据是否相等。
  - 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试

\###04.27_day04总结 把今天的知识点总结一遍。



\###07.01_面向对象(构造方法Constructor概述和格式)(掌握)

- A:构造方法概述和作用
  - 给对象的数据(属性)进行初始化
- B:构造方法格式特点
  - a:方法名与类名相同(大小也要与类名一致)
  - b:没有返回值类型，连void都没有
  - c:没有具体的返回值return;

\###07.02_面向对象(构造方法的重载及注意事项)(掌握)

- A:案例演示
  - 构造方法的重载
  - 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表
- B:构造方法注意事项
  - a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。
  - b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。
    - 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法

\###07.03_面向对象(给成员变量赋值的两种方式的区别)

- A:setXxx()方法
  - 修改属性值 
- B:构造方法
  - 给对象中属性进行初始化 

\###07.04_面向对象(学生类的代码及测试)(掌握)

- A:案例演示
  - 学生类：
    - 成员变量：
      - name，age
    - 构造方法：
      - 无参，带两个参
    - 成员方法：
      - getXxx()/setXxx()
      - show()：输出该类的所有成员变量值
- B:给成员变量赋值：
  - a:setXxx()方法
  - b:构造方法
- C:输出成员变量值的方式：
  - a:通过getXxx()分别获取然后拼接
  - b:通过调用show()方法搞定

\###07.05_面向对象(手机类的代码及测试)(掌握)

- A:案例演示
  - 模仿学生类，完成手机类代码

\###07.06_面向对象(创建一个对象的步骤)(掌握)

- A:画图演示
  - 画图说明一个对象的创建过程做了哪些事情?
  - Student s = new Student();
  - 1,Student.class加载进内存
  - 2,声明一个Student类型引用s
  - 3,在堆内存创建对象,
  - 4,给对象中属性默认初始化值
  - 5,属性进行显示初始化
  - 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈
  - 7,将对象的地址值赋值给s

\###07.07_面向对象(长方形案例练习)(掌握)

- A:案例演示
  - 需求：
    - 定义一个长方形类,定义 求周长和面积的方法，
    - 然后定义一个测试类进行测试。

\###07.08_面向对象(员工类案例练习)(掌握)

- A:案例演示
  - 需求：定义一个员工类Employee
  - 自己分析出几个成员，然后给出成员变量
    - 姓名name,工号id,工资salary 
  - 构造方法，
    - 空参和有参的
  - getXxx()setXxx()方法，
  - 以及一个显示所有成员信息的方法。并测试。
    - work 

\###07.09_面向对象(static关键字及内存图)(了解)

- A:案例演示
  - 通过一个案例引入static关键字。
  - 人类：Person。每个人都有国籍，中国。
- B:画图演示
  - 带有static的内存图

\###07.10_面向对象(static关键字的特点)(掌握)

- A:static关键字的特点
  - a:随着类的加载而加载
  - b:优先于对象存在
  - c:被类的所有对象共享
    - 举例：咱们班级的学生应该共用同一个班级编号。
    - 其实这个特点也是在告诉我们什么时候使用静态?
      - 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。
    - 举例：
      - 饮水机(用静态修饰)
      - 水杯(不能用静态修饰)
      - 共性用静态,特性用非静态
  - d:可以通过类名调用
    - 其实它本身也可以通过对象名调用。
    - 推荐使用类名调用。
    - 静态修饰的内容一般我们称其为：与类相关的，类成员
- B:案例演示
  - static关键字的特点

\###07.11_面向对象(static的注意事项)(掌握)

- A:static的注意事项
  - a:在静态方法中是没有this关键字的
    - 如何理解呢?
      - 静态是随着类的加载而加载，this是随着对象的创建而存在。
      - 静态比对象先存在。
  - b:静态方法只能访问静态的成员变量和静态的成员方法
    - 静态方法：
      - 成员变量：只能访问静态变量
      - 成员方法：只能访问静态成员方法
    - 非静态方法：
      - 成员变量：可以是静态的，也可以是非静态的
      - 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。
    - 简单记：
      - 静态只能访问静态。
- B:案例演示
  - static的注意事项

\###07.12_面向对象(静态变量和成员变量的区别)(掌握)

- 静态变量也叫类变量  成员变量也叫对象变量
- A:所属不同
  - 静态变量属于类，所以也称为为类变量
  - 成员变量属于对象，所以也称为实例变量(对象变量)
- B:内存中位置不同
  - 静态变量存储于方法区的静态区
  - 成员变量存储于堆内存
- C:内存出现时间不同
  - 静态变量随着类的加载而加载，随着类的消失而消失
  - 成员变量随着对象的创建而存在，随着对象的消失而消失
- D:调用不同
  - 静态变量可以通过类名调用，也可以通过对象调用
  - 成员变量只能通过对 象名调用

\###07.13_面向对象(main方法的格式详细解释)(了解)

- A:格式
  - public static void main(String[] args) {}
- B:针对格式的解释
  - public 被jvm调用，访问权限足够大。
  - static 被jvm调用，不用创建对象，直接类名访问
  - void被jvm调用，不需要给jvm返回值
  - main 一个通用的名称，虽然不是关键字，但是被jvm识别
  - String[] args 以前用于接收键盘录入的
- C:演示案例
  - 通过args接收键盘例如数据

\###07.14_面向对象(工具类中使用静态)(了解)

- A:制作一个工具类
  - ArrayTool
  - 1,获取最大值
  - 2,数组的遍历
  - 3,数组的反转

\###07.15_面向对象(说明书的制作过程)(了解)

- A:对工具类加入文档注释
- B:通过javadoc命令生成说明书
  - @author(提取作者内容)
  - @version(提取版本内容)
  - javadoc -d 指定的文件目录 -author -version ArrayTool.java
  - @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据

\###07.16_面向对象(如何使用JDK提供的帮助文档)(了解)

- A:找到文档，打开文档
- B:点击显示，找到索引，出现输入框
- C:你应该知道你找谁?举例：Scanner
- D:看这个类的结构(需不需要导包)
  - 成员变量	字段
  - 构造方法	构造方法
  - 成员方法	方法

\###07.17_面向对象(学习Math类的随机数功能)(了解)

- 打开JDK提供的帮助文档学习
- A:Math类概述
  - 类包含用于执行基本数学运算的方法
- B:Math类特点
  - 由于Math类在java.lang包下，所以不需要导包。
  - 因为它的成员全部是静态的,所以私有了构造方法
- C:获取随机数的方法
  - public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。
- D:我要获取一个1-100之间的随机数，肿么办?
  - int number = (int)(Math.random()*100)+1;

\###07.18_面向对象(猜数字小游戏案例)(了解)

- A:案例演示
  - 需求：猜数字小游戏(数据在1-100之间)

\###07.19_day07总结 把今天的知识点总结一遍。



\###08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)

- A:代码块概述
  - 在Java中，使用{}括起来的代码被称为代码块。
- B:代码块分类
  - 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。
- C:常见代码块的应用
  - a:局部代码块 
    - 在方法中出现；限定变量生命周期，及早释放，提高内存利用率
  - b:构造代码块 (初始化块)
    - 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
  - c:静态代码块 
    - 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。
    - 一般用于加载驱动

\###08.02_面向对象(代码块的面试题)(掌握)

- A:看程序写结果
- class Student { static {   			System.out.println("Student 静态代码块");   		}



```

```











```
    {
        System.out.println("Student 构造代码块");
    }
    
    public Student() {
        System.out.println("Student 构造方法");
    }
  }
  
  class Demo2_Student {
    static {
        System.out.println("Demo2_Student静态代码块");
    }
    
    public static void main(String[] args) {
        System.out.println("我是main方法");
        
        Student s1 = new Student();
        Student s2 = new Student();
    }
  }
```



\###08.03_面向对象(继承案例演示)(掌握)

- A:继承(extends)
  - 让类与类之间产生关系,子父类关系 
- B:继承案例演示：
  - 动物类,猫类,狗类
  - 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)
- C:案例演示
  - 使用继承前
- D:案例演示
  - 使用继承后

\###08.04_面向对象(继承的好处和弊端)(掌握)

- A:继承的好处
  - a:提高了代码的复用性
  - b:提高了代码的维护性
  - c:让类与类之间产生了关系，是多态的前提
- B:继承的弊端
  - 类的耦合性增强了。
  - 开发的原则：高内聚，低耦合。
  - 耦合：类与类的关系
  - 内聚：就是自己完成某件事情的能力

\###08.05_面向对象(Java中类的继承特点)(掌握)

- A:Java中类的继承特点
  - a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)
    - 有些语言是支持多继承，格式：extends 类1,类2,...
  - b:Java支持多层继承(继承体系)
- B:案例演示
  - Java中类的继承特点
    - 如果想用这个体系的所有功能用最底层的类创建对象
    - 如果想看这个体系的共性功能,看最顶层的类 

\###08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)

- A:继承的注意事项

  - a:子类只能继承父类所有非私有的成员(成员方法和成员变量)
  - b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。
  - c:不要为了部分功能而去继承
  - 项目经理 姓名 工号 工资 奖金
  - 程序员	姓名 工号 工资

- B:什么时候使用继承

  - 继承其实体现的是一种关系："is a"。 Person 	Student 	Teacher 水果 	苹果 	香蕉 	橘子 	

  采用假设法。 	如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。

\###08.07_面向对象(继承中成员变量的关系)(掌握)

- A:案例演示
  - a:不同名的变量
  - b:同名的变量 ###08.08_面向对象(this和super的区别和应用)(掌握)
- A:this和super都代表什么
  - this:代表当前对象的引用,谁来调用我,我就代表谁
  - super:代表当前对象父类的引用
- B:this和super的使用区别
  - a:调用成员变量
    - this.成员变量 调用本类的成员变量,也可以调用父类的成员变量
    - super.成员变量 调用父类的成员变量
  - b:调用构造方法
    - this(...)	调用本类的构造方法
    - super(...)	调用父类的构造方法
  - c:调用成员方法
    - this.成员方法 调用本类的成员方法,也可以调用父类的方法
    - super.成员方法 调用父类的成员方法

\###08.09_面向对象(继承中构造方法的关系)(掌握)

- A:案例演示
  - 子类中所有的构造方法默认都会访问父类中空参数的构造方法
- B:为什么呢?
  - 因为子类会继承父类中的数据，可能还会使用父类的数据。
  - 所以，子类初始化之前，一定要先完成父类数据的初始化。
  - 其实：
    - 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。

\###08.10_面向对象(继承中构造方法的注意事项)(掌握)

- A:案例演示
  - 父类没有无参构造方法,子类怎么办?
  - super解决
  - this解决
- B:注意事项
  - super(…)或者this(….)必须出现在构造方法的第一条语句上

\###08.11_面向对象(继承中的面试题)(掌握)

- A:案例演示

- 

  ```
  
  ```











  ```
  看程序写结果1
  ```

  ```
  class Fu{
  ```

  ```
      public int num = 10;
  ```

  ```
      public Fu(){
  ```

  ```
          System.out.println("fu");
  ```

  ```
      }
  ```

  ```
  }
  ```

  ```
  class Zi extends Fu{
  ```

  ```
      public int num = 20;
  ```

  ```
      public Zi(){
  ```

  ```
          System.out.println("zi");
  ```

  ```
      }
  ```

  ```
      public void show(){
  ```

  ```
          int num = 30;
  ```

  ```
          System.out.println(num);
  ```

  ```
          System.out.println(this.num);
  ```

  ```
          System.out.println(super.num);
  ```

  ```
      }
  ```

  ```
  }
  ```

  ```
  class Test1_Extends {
  ```

  ```
      public static void main(String[] args) {
  ```

  ```
          Zi z = new Zi();
  ```

  ```
          z.show();
  ```

  ```
      }
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  看程序写结果2
  ```

  ```
  class Fu {
  ```

  ```
      static {
  ```

  ```
          System.out.println("静态代码块Fu");
  ```

  ```
      }
  ```

  ```
  
  ```

  ```
      {
  ```

  ```
          System.out.println("构造代码块Fu");
  ```

  ```
      }
  ```

  ```
  
  ```

  ```
      public Fu() {
  ```

  ```
          System.out.println("构造方法Fu");
  ```

  ```
      }
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  class Zi extends Fu {
  ```

  ```
      static {
  ```

  ```
          System.out.println("静态代码块Zi");
  ```

  ```
      }
  ```

  ```
  
  ```

  ```
      {
  ```

  ```
          System.out.println("构造代码块Zi");
  ```

  ```
      }
  ```

  ```
  
  ```

  ```
      public Zi() {
  ```

  ```
          System.out.println("构造方法Zi");
  ```

  ```
      }
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  Zi z = new Zi(); 请执行结果。
  ```


\###08.12_面向对象(继承中成员方法关系)(掌握)

- A:案例演示
  - a:不同名的方法
  - b:同名的方法

\###08.13_面向对象(方法重写概述及其应用)(掌握)

- A:什么是方法重写
  - 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) 
- B:方法重写的应用：
  - 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。
- C:案例演示
  - a:定义一个手机类。

\###08.14_面向对象(方法重写的注意事项)(掌握)

- A:方法重写注意事项
  - a:父类中私有方法不能被重写
    - 因为父类私有方法子类根本就无法继承
  - b:子类重写父类方法时，访问权限不能更低
    - 最好就一致
  - c:父类静态方法，子类也必须通过静态方法进行重写
    - 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)
  - 子类重写父类方法的时候，最好声明一模一样。
- B:案例演示
  - 方法重写注意事项

\###08.15_面向对象(方法重写的面试题)(掌握)

- A:方法重写的面试题
  - Override和Overload的区别?Overload能改变返回值类型吗?
  - overload可以改变返回值类型,只看参数列表
  - 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的
  - 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。
  - 子类对象调用方法的时候：
    - 先找子类本身，再找父类。

\###08.16_面向对象(使用继承前的学生和老师案例)(掌握)

- A:案例演示
  - 使用继承前的学生和老师案例
  - 属性:姓名,年龄
  - 行为:吃饭
  - 老师有特有的方法:讲课
  - 学生有特有的方法:学习

\###08.17_面向对象(使用继承后的学生和老师案例)(掌握)

- A:案例演示
  - 使用继承后的学生和老师案例

\###08.18_面向对象(猫狗案例分析,实现及测试)(掌握)

- A:猫狗案例分析
- B:案例演示
  - 猫狗案例继承版
  - 属性:毛的颜色,腿的个数
  - 行为:吃饭
  - 猫特有行为:抓老鼠catchMouse
  - 狗特有行为:看家lookHome

\###08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)

- A:final概述
- B:final修饰特点
  - 修饰类，类不能被继承
  - 修饰变量，变量就变成了常量，只能被赋值一次
  - 修饰方法，方法不能被重写
- C:案例演示
  - final修饰特点

\###08.20_面向对象(final关键字修饰局部变量)(掌握)

- A:案例演示
  - 方法内部或者方法声明上都演示一下(了解)
  - 基本类型，是值不能被改变
  - 引用类型，是地址值不能被改变,对象中的属性可以改变

\###08.21_面向对象(final修饰变量的初始化时机)(掌握)

- A:final修饰变量的初始化时机
  - 显示初始化 
  - 在对象构造完毕前即可

\###08.22_day08总结

- 把今天的知识点总结一遍。



\###09.01_面向对象(多态的概述及其代码体现)

- A:多态(polymorphic)概述
  - 事物存在的多种形态 
- B:多态前提
  - a:要有继承关系。
  - b:要有方法重写。
  - c:要有父类引用指向子类对象。
- C:案例演示
  - 代码体现多态

\###09.02_面向对象(多态中的成员访问特点之成员变量)

- 成员变量
  - 编译看左边(父类)，运行看左边(父类)。

\###09.03_面向对象(多态中的成员访问特点之成员方法)

- 成员方法
  - 编译看左边(父类)，运行看右边(子类)。

\###09.04_面向对象(多态中的成员访问特点之静态成员方法)

- 静态方法
  - 编译看左边(父类)，运行看左边(父类)。
  - (静态和类相关，算不上重写，所以，访问还是左边的)
  - 只有非静态的成员方法,编译看左边,运行看右边 

\###09.05_面向对象(超人的故事)

- A:案例分析
  - 通过该案例帮助学生理解多态的现象

\###09.06_面向对象(多态中向上转型和向下转型)

- A:案例演示
  - 详细讲解多态中向上转型和向下转型 Person p = new SuperMan();向上转型 SuperMan sm = (SuperMan)p;向下转型 ###09.07_面向对象(多态的好处和弊端)
- A:多态的好处
  - a:提高了代码的维护性(继承保证)
  - b:提高了代码的扩展性(由多态保证)
- B:案例演示
  - 多态的好处
  - 可以当作形式参数,可以接收任意子类对象
- C:多态的弊端
  - 不能使用子类的特有属性和行为。
- D:案例演示 method(Animal a) method(Cat c)

\###09.08_面向对象(多态中的题目分析题)

- A:看下面程序是否有问题，如果没有，说出结果
- class Fu { public void show() {   			System.out.println("fu show");   		}   	}



```

```











```
  class Zi extends Fu {
    public void show() {
        System.out.println("zi show");
    }
  
    public void method() {
        System.out.println("zi method");
    }
  }
  
  class Test1Demo {
    public static void main(String[] args) {
        Fu f = new Zi();
        f.method();
        f.show();
    }
  }
```



- B:看下面程序是否有问题，如果没有，说出结果
- class A { public void show() {   			show2();   		}   		public void show2() {   			System.out.println("我");   		}   	}   	class B extends A {   		public void show2() {   			System.out.println("爱");   		}   	}   	class C extends B {   		public void show() {   			super.show();   		}   		public void show2() {   			System.out.println("你");   		}   	}   	public class Test2DuoTai {   		public static void main(String[] args) {   			A a = new B();   			a.show();



```

```











```
        B b = new C();
        b.show();
    }
  }
```



\###09.09_面向对象(抽象类的概述及其特点)

- A:抽象类概述
  - 抽象就是看不懂的 
- B:抽象类特点
  - a:抽象类和抽象方法必须用abstract关键字修饰
    - abstract class 类名 {}
    - public abstract void eat();
  - b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口
  - c:抽象类不能实例化那么，抽象类如何实例化呢?
    - 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。
  - d:抽象类的子类
    - 要么是抽象类
    - 要么重写抽象类中的所有抽象方法
- C:案例演示
  - 抽象类特点B:抽象类特点
  - a:抽象类和抽象方法必须用abstract关键字修饰
    - abstract class 类名 {}
    - public abstract void eat();
  - b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口
  - c:抽象类不能实例化那么，抽象类如何实例化呢?
    - 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。
  - d:抽象类的子类
    - 要么是抽象类
    - 要么重写抽象类中的所有抽象方法

\###09.10_面向对象(抽象类的成员特点)

- A:抽象类的成员特点
  - a:成员变量：既可以是变量，也可以是常量。abstract是否可以修饰成员变量?不能修饰成员变量
  - b:构造方法：有。
    - 用于子类访问父类数据的初始化。
  - c:成员方法：既可以是抽象的，也可以是非抽象的。
- B:案例演示
  - 抽象类的成员特点
- C:抽象类的成员方法特性：
  - a:抽象方法 强制要求子类做的事情。
  - b:非抽象方法 子类继承的事情，提高代码复用性。

\###09.11_面向对象(葵花宝典)

- 案例演示
  - 抽象类的作用  ###09.12_面向对象(抽象类练习猫狗案例)
- A:案例演示
  - 具体事物：猫，狗
  - 共性：姓名，年龄，吃饭
  - 猫的特性:抓老鼠
  - 狗的特性:看家

\###09.13_面向对象(抽象类练习老师案例)

- A:案例演示
  - 具体事物：基础班老师，就业班老师
  - 共性：姓名，年龄，讲课。
  - 具体事物:基础班学生,就业班学生
  - 共性:姓名,年龄,学习

\###09.14_面向对象(抽象类练习员工案例)

- A:案例演示
  - 假如我们在开发一个系统时需要对程序员类进行设计，程序员包含3个属性：姓名、工号以及工资。
  - 经理，除了含有程序员的属性外，另为还有一个奖金属性。
  - 请使用继承的思想设计出程序员类和经理类。要求类中提供必要的方法进行属性访问。

\###09.15_面向对象(抽象类中的面试题)

- A:面试题1
  - 一个抽象类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?
  - 可以
  - 这么做目的只有一个,就是不让其他类创建本类对象,交给子类完成
- B:面试题2
  - abstract不能和哪些关键字共存

\###09.16_面向对象(接口的概述及其特点)

- A:接口概述
  - 从狭义的角度讲就是指java中的interface
  - 从广义的角度讲对外提供规则的都是接口 
- B:接口特点
  - a:接口用关键字interface表示	
    - interface 接口名 {}
  - b:类实现接口用implements表示
    - class 类名 implements 接口名 {}
  - c:接口不能实例化
    - 那么，接口如何实例化呢?
    - 按照多态的方式来实例化。
  - d:接口的子类
    - a:可以是抽象类。但是意义不大。
    - b:可以是具体类。要重写接口中的所有抽象方法。(推荐方案)
- C:案例演示
  - 接口特点

\###09.17_面向对象(接口的成员特点)

- A:接口成员特点
  - 成员变量；只能是常量，并且是静态的并公共的。
    - 默认修饰符：public static final
      - 建议：自己手动给出。
  - 构造方法：接口没有构造方法。
  - 成员方法：只能是抽象方法。
    - 默认修饰符：public abstract
      - 建议：自己手动给出。
- B:案例演示
  - 接口成员特点

\###09.18_面向对象(类与类,类与接口,接口与接口的关系)

- A:类与类,类与接口,接口与接口的关系
  - a:类与类：
    - 继承关系,只能单继承,可以多层继承。
  - b:类与接口：
    - 实现关系,可以单实现,也可以多实现。
    - 并且还可以在继承一个类的同时实现多个接口。
  - c:接口与接口：
    - 继承关系,可以单继承,也可以多继承。
- B:案例演示
  - 类与类,类与接口,接口与接口的关系

\###09.19_面向对象(抽象类和接口的区别)

- A:成员区别
  - 抽象类：
    - 成员变量：可以变量，也可以常量
    - 构造方法：有
    - 成员方法：可以抽象，也可以非抽象
  - 接口：
    - 成员变量：只可以常量
    - 成员方法：只可以抽象
- B:关系区别
  - 类与类
    - 继承，单继承
  - 类与接口
    - 实现，单实现，多实现
  - 接口与接口
    - 继承，单继承，多继承
- C:设计理念区别
  - 抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。
  - 接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。

\###09.20_面向对象(猫狗案例加入跳高功能分析及其代码实现)

- A:案例演示
  - 动物类：姓名，年龄，吃饭，睡觉。
  - 猫和狗
  - 动物培训接口：跳高

\###09.21_day09总结

- 把今天的知识点总结一遍。



\###11.01_Java开发工具(常见开发工具介绍)(了解)

- A:操作系统自带的记事本软件
- B:高级记事本软件
- C:集成开发环境 IDE
  - (Integrated Development Environment)
- D:Eclipse和MyEclipse的区别
  - a:Eclipse是一种可扩展的开放源代码的IDE。
  - b:Eclipse的特点描述
    - 免费
    - 纯Java语言编写
    - 免安装
    - 扩展性强
  - c:MyEclipse
    - 在Eclipse基础上追加的功能性插件，对插件收费
    - 在WEB开发中提供强大的系统架构平台
- E:下载 <http://eclipse.org/>
  - org是非盈利团体 
- F:安装
  - 绿色版	解压就可以使用(Eclipse)
  - 安装版   双击运行,一路next即可(JDK)
- G:卸载
  - 绿色版	直接删除文件夹即可
  - 安装版 专业卸载软件或者控制面板添加删除程序

\###11.02_Java开发工具(Eclipse中HelloWorld案例以及汉化)(了解)

- A:选择工作空间
  - 工作空间  其实就是我们写的源代码所在的目录
- B:用Eclipse来完成一个HelloWorld案例
  - 代码以项目为基本单位
  - 创建项目
  - 创建包
  - 创建类
  - 编写代码
- C:编译和运行
- D:Eclipse的汉化
  - 从Eclipse3.5开始，安装目录下就多了一个dropins目录,只要将插件解压后放到到该目录即可。
  - 同理，这种方式卸载插件也是特别的方便，推荐这种方式
- E:语法检查提示
  - 红色波浪线
    - 必须处理,否则编译通不过
  - 黄色波浪线	
    - 可以不搭理他 

\###11.03_Java开发工具(Eclipse的视窗和视图概述)(了解)

- A:视窗  每一个基本的窗体被称为视窗
  - PackageExplorer  显示项目结构，包，类，及资源
  - Outline   显示类的结构，方便查找，识别，修改
  - Console  程序运行的结果在该窗口显示
  - Hierarchy 显示Java继承层次结构，选中类后F4
- B:视图  是由某些视窗的组合而成的
  - Java视图
  - Debug视图

\###11.04_Java开发工具(Eclipse工作空间的基本配置)(掌握)

- A:程序的编译和运行的环境配置(一般不改)
  - window -- Preferences -- Java
  - 编译环境：Compiler	默认选中的就是最高版本。
  - 运行环境：Installed JREs	默认会找你安装的那个JDK。建议配置了Java的环境变量。
  - 问题：
    - 低编译，高运行。可以。
    - 高编译，低运行。不可以。
    - 建议，编译和运行的版本一致。
- B:如何去掉默认注释?
  - window -- Preferences -- Java -- Code Style -- Code Templates
  - 选择你不想要的内容，通过右边Edit编辑。
  - 注意：请只删除注释部分，不是注释部分的不要删除。
- C:行号的显示和隐藏
  - 显示：在代码区域的最左边的空白区域，右键 -- Show Line Numbers即可。
  - 隐藏：把上面的动作再做一次。
- D:字体大小及颜色
  - a:Java代码区域的字体大小和颜色：
    - window -- Preferences -- General -- Appearance -- Colors And Fonts --Java修改 -- Java Edit Text Font
  - b:控制台
    - window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font
  - c:其他文件
    - window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font
- E:窗体给弄乱了，怎么办?
  - window -- Reset Perspective
- F:控制台找不到了，怎么办?
  - Window--Show View—Console
- G:取消悬浮提示
  - window -- Preferences -- Java--Editor--Hovers。右边将Combined Hover勾去掉。
  - 这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可。

\###11.05_Java开发工具(Eclipse中内容辅助键的使用)(掌握)

- A:Alt+/ 起提示作用
- B:main+alt+/,syso+alt+/,给出其他提示
- C:补充输出语句,选中需要输出的部分,alt+/选择最后一项即可
- C:定义自己的alt + /
  - windows--perference-Java-Editor-Templates--New

\###11.06_Java开发工具(Eclipse中快捷键的使用)(掌握)

- A:新建 ctrl + n
- B:格式化  ctrl+shift+f
- C:导入包  ctrl+shift+o 
- D:注释  ctrl+/,ctrl+shift+/,ctrl+shift+\
- E:代码上下移动 选中代码alt+上/下箭头
- F:查看源码  选中类名(F3或者Ctrl+鼠标点击)
- G:查找具体的类 ctrl + shift + t
- H:查找具体类的具体方法 ctrl + o
- I:给建议 ctrl+1,根据右边生成左边的数据类型,生成方法
- J:删除代码 ctrl + d
- K:抽取方法alt + shift + m 
- L:改名alt + shift + r 
- 

\###11.07_Java开发工具(Eclipse中如何提高开发效率)(掌握)

- alt + shift + s
- A:自动生成构造方法
- B:自动生成get/set方法

\###11.08_Java开发工具(Eclipse中一个标准学生类及其测试)(掌握)

- A:案例演示
  - 用Eclipse实现标准学生类及其测试

\###11.09_Java开发工具(Eclipse中接口抽象类具体类代码体现)(掌握)

- A:案例演示
  - 用Eclipse实现接口抽象类具体类代码

\###11.10_Java开发工具(Eclipse中如何生成jar包并导入到项目中)(了解)

- A:jar是什么?
  - jar是多个class文件的压缩包。
- B:jar有什么用?
  - 用别人写好的东西	
- C:打jar包
  - 选中项目--右键--Export--Java--Jar--自己指定一个路径和一个名称--Finish
- D:导入jar包
  - 复制到项目路径下并添加至构建路径。

\###11.11_Java开发工具(Eclipse中如何删除项目和导入项目)(掌握)

- A:删除项目
  - 选中项目 – 右键 – 删除
    - 从项目区域中删除
    - 从硬盘上删除
- B:导入项目
  - 在项目区域右键找到import
  - 找到General，展开，并找到
  - Existing Projects into Workspace
  - 点击next,然后选择你要导入的项目
  - 注意：这里选择的是项目名称

\###11.12_Java开发工具(Eclipse中断点调试的基本使用)(了解)

- A:Debug的作用
  - 调试程序
  - 查看程序执行流程
- B:如何查看程序执行流程		
  - 什么是断点：
    - 就是一个标记，从哪里开始。
  - 如何设置断点：
    - 你想看哪里的程序，你就在那个有效程序的左边双击即可。
  - 在哪里设置断点：
    - 哪里不会点哪里。
    - 目前：我们就在每个方法的第一条有效语句上都加。
  - 如何运行设置断点后的程序：
    - 右键 -- Debug as -- Java Application
  - 看哪些地方：
    - Debug：断点测试的地方
      - 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。
    - Variables：查看程序的变量变化
    - ForDemo：被查看的源文件
    - Console：控制台
  - 如何去断点：
    - a:再次双击即可
    - b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉。

\###11.13_Java开发工具(Eclipse查看Java中参数传递问题)(了解)

- A:断点演示
  - 断点查看Java中参数传递问题

\###11.14_常见对象(API概述)(了解)

- A:API(Application Programming Interface) 
  - 应用程序编程接口
- B:Java API
  - 就是Java提供给我们使用的类，这些类将底层的实现封装了起来，
  - 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。

\###11.15_常见对象(Object类的概述)(了解)

- A:Object类概述
  - 类层次结构的根类
  - 所有类都直接或者间接的继承自该类
- B:构造方法
  - public Object()
  - 回想面向对象中为什么说：
  - 子类的构造方法默认访问的是父类的无参构造方法

\###11.16_常见对象(Object类的hashCode()方法)(了解)

- A:案例演示
  - public int hashCode()
  - a:返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。
  - b:不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。

\###11.17_常见对象(Object类的getClass()方法)(在反射的时候掌握)

- A:案例演示
  - public final Class getClass()
  - a:返回此 Object 的运行时类。
  - b:可以通过Class类中的一个方法，获取对象的真实类的全名称。	
    - public String getName()

\###11.18_常见对象(Object类的toString()方法)(掌握)

- A:案例演示
  - public String toString()
  - a:返回该对象的字符串表示。
-   public Stirng toString() {   		return name + "," + age;   	}
- b:它的值等于： 
  - getClass().getName() + "@" + Integer.toHexString(hashCode()) 
- c:由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。
- B:最终版
  - 自动生成

\###11.19_常见对象(Object类的equals()方法)(掌握)

- A:案例演示
  - a:指示其他某个对象是否与此对象“相等”。 
  - b:默认情况下比较的是对象的引用是否相同。
  - c:由于比较对象的引用没有意义，一般建议重写该方法。

\###11.20_常见对象(==号和equals方法的区别)(掌握)

- ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值
- equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性

\###11.21_day11总结

- 把今天的知识点总结一遍。

\###12.01_常见对象(Scanner的概述和方法介绍)(掌握)

- A:Scanner的概述
- B:Scanner的构造方法原理
  - Scanner(InputStream source)
  - System类下有一个静态的字段：
    - public static final InputStream in; 标准的输入流，对应着键盘录入。
- C:一般方法
  - hasNextXxx()  判断是否还有下一个输入项,其中Xxx可以是Int,Double等。如果需要判断是否包含下一个字符串，则可以省略Xxx
  - nextXxx()  获取下一个输入项。Xxx的含义和上个方法中的Xxx相同,默认情况下，Scanner使用空格，回车等作为分隔符

\###12.02_常见对象(Scanner获取数据出现的小问题及解决方案)(掌握)

- A:两个常用的方法：
  - public int nextInt():获取一个int类型的值
  - public String nextLine():获取一个String类型的值
- B:案例演示
  - a:先演示获取多个int值，多个String值的情况
  - b:再演示先获取int值，然后获取String值出现问题
  - c:问题解决方案
    - 第一种：先获取一个数值后，在创建一个新的键盘录入对象获取字符串。
    - 第二种：把所有的数据都先按照字符串获取，然后要什么，你就对应的转换为什么。(后面讲)

\###12.03_常见对象(String类的概述)(掌握)

- A:String类的概述	
  - 通过JDK提供的API，查看String类的说明
  - 可以看到这样的两句话。
    - a:字符串字面值"abc"也可以看成是一个字符串对象。
    - b:字符串是常量，一旦被赋值，就不能被改变。

\###12.04_常见对象(String类的构造方法)(掌握)

- A:常见构造方法
  - public String():空构造
  - public String(byte[] bytes):把字节数组转成字符串
  - public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串
  - public String(char[] value):把字符数组转成字符串
  - public String(char[] value,int index,int count):把字符数组的一部分转成字符串
  - public String(String original):把字符串常量值转成字符串
- B:案例演示	
  - 演示String类的常见构造方法

\###12.05_常见对象(String类的常见面试题)(掌握)

- 1.判断定义为String类型的s1和s2是否相等
  - String s1 = "abc";
  - String s2 = "abc";
  - System.out.println(s1 == s2); 					
  - System.out.println(s1.equals(s2)); 		
- 2.下面这句话在内存中创建了几个对象?
  - String s1 = new String("abc");			
- 3.判断定义为String类型的s1和s2是否相等
  - String s1 = new String("abc");			
  - String s2 = "abc";
  - System.out.println(s1 == s2);		
  - System.out.println(s1.equals(s2));
- 4.判断定义为String类型的s1和s2是否相等
  - String s1 = "a" + "b" + "c";
  - String s2 = "abc";
  - System.out.println(s1 == s2);		
  - System.out.println(s1.equals(s2));
- 5.判断定义为String类型的s1和s2是否相等
  - String s1 = "ab";
  - String s2 = "abc";
  - String s3 = s1 + "c";
  - System.out.println(s3 == s2);
  - System.out.println(s3.equals(s2));

\###12.06_常见对象(String类的判断功能)(掌握)

- A:String类的判断功能
  - boolean equals(Object obj):比较字符串的内容是否相同,区分大小写
  - boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
  - boolean contains(String str):判断大字符串中是否包含小字符串
  - boolean startsWith(String str):判断字符串是否以某个指定的字符串开头
  - boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾
  - boolean isEmpty():判断字符串是否为空。

\###12.07_常见对象(模拟用户登录)(掌握)

- A:案例演示
  - 需求：模拟登录,给三次机会,并提示还有几次。
  - 用户名和密码都是admin

\###12.08_常见对象(String类的获取功能)(掌握)

- A:String类的获取功能
  - int length():获取字符串的长度。
  - char charAt(int index):获取指定索引位置的字符
  - int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。
  - int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。
  - int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。
  - int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。
  - lastIndexOf
  - String substring(int start):从指定位置开始截取字符串,默认到末尾。
  - String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。

\###12.09_常见对象(字符串的遍历)(掌握)

- A:案例演示
  - 需求：遍历字符串

\###12.10_常见对象(统计不同类型字符个数)(掌握)

- A:案例演示
  - 需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数,其他字符出现的次数。
  - ABCDEabcd123456!@#$%^

\###12.11_常见对象(String类的转换功能)(掌握)

- A:String的转换功能：
  - byte[] getBytes():把字符串转换为字节数组。
  - char[] toCharArray():把字符串转换为字符数组。
  - static String valueOf(char[] chs):把字符数组转成字符串。
  - static String valueOf(int i):把int类型的数据转成字符串。
    - 注意：String类的valueOf方法可以把任意类型的数据转成字符串
  - String toLowerCase():把字符串转成小写。(了解)
  - String toUpperCase():把字符串转成大写。
  - String concat(String str):把字符串拼接。

\###12.12_常见对象(按要求转换字符)(链式编程掌握)

- A:案例演示
  - 需求：把一个字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符)

\###12.13_常见对象(把数组转成字符串)

- A:案例演示
  - 需求：把数组中的数据按照指定个格式拼接成一个字符串
    - 举例：
      - int[] arr = {1,2,3};	
    - 输出结果：
      - "[1, 2, 3]" ###12.14_常见对象(String类的其他功能)
- A:String的替换功能及案例演示
  - String replace(char old,char new)
  - String replace(String old,String new)
- B:String的去除字符串两空格及案例演示
  - String trim()
- C:String的按字典顺序比较两个字符串及案例演示
  - int compareTo(String str)(暂时不用掌握)
  - int compareToIgnoreCase(String str)(了解)

\###12.15_常见对象(字符串反转)

- A:案例演示
  - 需求：把字符串反转
    - 举例：键盘录入"abc"		
    - 输出结果："cba"

\###12.16_常见对象(在大串中查找小串出现的次数思路图解)

- A:画图演示
  - 需求：统计大串中小串出现的次数
  - 这里的大串和小串可以自己根据情况给出

\###12.17_常见对象(在大串中查找小串出现的次数代码实现)

- A:案例演示	
  - 统计大串中小串出现的次数

\###12.18_day12总结

- 把今天的知识点总结一遍。



﻿###19.01_异常(异常的概述和分类)

- A:异常的概述
  - 异常就是Java程序在运行过程中出现的错误。
- B:异常的分类
  - 通过API查看Throwable
  - Error
    - 服务器宕机,数据库崩溃等
  - Exception C:异常的继承体系
  - Throwable
    - Error	
    - Exception
      - RuntimeException

\###19.02_异常(JVM默认是如何处理异常的)

- A:JVM默认是如何处理异常的
  - main函数收到这个问题时,有两种处理方式:
  - a:自己将该问题处理,然后继续运行
  - b:自己没有针对的处理方式,只有交给调用main的jvm来处理
  - jvm有一个默认的异常处理机制,就将该异常进行处理.
  - 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行
- B:案例演示
  - JVM默认如何处理异常

\###19.03_异常(try...catch的方式处理异常1)

- A:异常处理的两种方式
  - a:try…catch…finally
    - try catch
    - try catch finally
    - try finally 
  - b:throws
- B:try...catch处理异常的基本格式
  - try…catch…finally
- C:案例演示
  - try...catch的方式处理1个异常

\###19.04_异常(try...catch的方式处理异常2)

- A:案例演示
  - try...catch的方式处理多个异常
  - JDK7以后处理多个异常的方式及注意事项

\###19.05_异常(编译期异常和运行期异常的区别)

- A:编译期异常和运行期异常的区别
  - Java中的异常被分为两大类：编译时异常和运行时异常。
  - 所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常
  - 编译时异常
    - Java程序必须显示处理，否则程序就会发生错误，无法通过编译
  - 运行时异常
    - 无需显示处理，也可以和编译时异常一样处理
- B:案例演示
  - 编译期异常和运行期异常的区别

\###19.06_异常(Throwable的几个常见方法)

- A:Throwable的几个常见方法
  - a:getMessage()
    - 获取异常信息，返回字符串。
  - b:toString()
    - 获取异常类名和异常信息，返回字符串。
  - c:printStackTrace()
    - 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。
- B:案例演示
  - Throwable的几个常见方法的基本使用

\###19.07_异常(throws的方式处理异常)

- A:throws的方式处理异常
  - 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。
  - 那么就通过throws在方法上标识。
- B:案例演示
  - 举例分别演示编译时异常和运行时异常的抛出

\###19.08_异常(throw的概述以及和throws的区别)

- A:throw的概述
  - 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。
- B:案例演示	
  - 分别演示编译时异常对象和运行时异常对象的抛出
- C:throws和throw的区别
  - a:throws
    - 用在方法声明后面，跟的是异常类名
    - 可以跟多个异常类名，用逗号隔开
    - 表示抛出异常，由该方法的调用者来处理
  - b:throw
    - 用在方法体内，跟的是异常对象名
    - 只能抛出一个异常对象名
    - 表示抛出异常，由方法体内的语句处理

\###19.09_异常(finally关键字的特点及作用)

- A:finally的特点
  - 被finally控制的语句体一定会执行
  - 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))
- B:finally的作用
  - 用于释放资源，在IO流操作和数据库操作中会见到
- C:案例演示
  - finally关键字的特点及作用

\###19.10_异常(finally关键字的面试题)

- A:面试题1
  - final,finally和finalize的区别
- B:面试题2
  - 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。

\###19.11_异常(自定义异常概述和基本使用)

- A:为什么需要自定义异常
  - 举例：人的年龄
- B:自定义异常概述
  - 继承自Exception
  - 继承自RuntimeException
- C:案例演示
  - 自定义异常的基本使用

\###19.12_异常(异常的注意事项及如何使用异常处理)

- A:异常注意事项
  - a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)
  - b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常
  - c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws
- B:如何使用异常处理
  - 原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws
  - 区别:
    - 后续程序需要继续运行就try
    - 后续程序不需要继续运行就throws
  - 如果JDK没有提供对应的异常，需要自定义异常。

\###19.13_异常(练习)

- 键盘录入一个int类型的整数,对其求二进制表现形式
  - 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger
  - 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数
  - 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数

\###19.14_File类(File类的概述和构造方法)

- A:File类的概述
  - File更应该叫做一个路径
    - 文件路径或者文件夹路径  
    - 路径分为绝对路径和相对路径
    - 绝对路径是一个固定的路径,从盘符开始
    - 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下
  - 查看API指的是当前路径
  - 文件和目录路径名的抽象表示形式
- B:构造方法
  - File(String pathname)：根据一个路径得到File对象
  - File(String parent, String child):根据一个目录和一个子文件/目录得到File对象
  - File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象
- C:案例演示
  - File类的构造方法

\###19.15_File类(File类的创建功能)

- A:创建功能
  - public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了
  - public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了
  - public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来
- B:案例演示
  - File类的创建功能
  - 注意事项：
    - 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。

\###19.16_File类(File类的重命名和删除功能)

- A:重命名和删除功能
  - public boolean renameTo(File dest):把文件重命名为指定的文件路径
  - public boolean delete():删除文件或者文件夹
- B:重命名注意事项
  - 如果路径名相同，就是改名。
  - 如果路径名不同，就是改名并剪切。
- C:删除注意事项：
  - Java中的删除不走回收站。
  - 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹

\###19.17_File类(File类的判断功能)

- A:判断功能
  - public boolean isDirectory():判断是否是目录
  - public boolean isFile():判断是否是文件
  - public boolean exists():判断是否存在
  - public boolean canRead():判断是否可读
  - public boolean canWrite():判断是否可写
  - public boolean isHidden():判断是否隐藏
- B:案例演示
  - File类的判断功能

\###19.18_File类(File类的获取功能)

- A:获取功能
  - public String getAbsolutePath()：获取绝对路径
  - public String getPath():获取路径
  - public String getName():获取名称
  - public long length():获取长度。字节数
  - public long lastModified():获取最后一次的修改时间，毫秒值
  - public String[] list():获取指定目录下的所有文件或者文件夹的名称数组
  - public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 
- B:案例演示
  - File类的获取功能

\###19.19_File类(输出指定目录下指定后缀的文件名)

- A:案例演示
  - 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称

\###19.20_File类(文件名称过滤器的概述及使用)

- A:文件名称过滤器的概述
  - public String[] list(FilenameFilter filter)
  - public File[] listFiles(FileFilter filter)
- B:文件名称过滤器的使用
  - 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称
- C:源码分析
  - 带文件名称过滤器的list()方法的源码



\###20.01_IO流(IO流概述及其分类)

- 1.概念
  - IO流用来处理设备之间的数据传输
  - Java对数据的操作是通过流的方式
  - Java用于操作流的类都在IO包中
  - 流按流向分为两种：输入流，输出流。
  - 流按操作类型分为两种：
    - 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的
    - 字符流 : 字符流只能操作纯字符数据，比较方便。
- 2.IO流常用父类
  - 字节流的抽象父类：
    - InputStream 
    - OutputStream
  - 字符流的抽象父类：
    - Reader 
    - Writer		
- 3.IO程序书写
  - 使用前，导入IO包中的类
  - 使用时，进行IO异常处理
  - 使用后，释放资源

\###20.02_IO流(FileInputStream)

- read()一次读取一个字节
- FileInputStream fis = new FileInputStream("aaa.txt");	//创建一个文件输入流对象,并关联aaa.txt int b;													//定义变量,记录每次读到的字节   	while((b = fis.read()) != -1) {							//将每次读到的字节赋值给b并判断是否是-1   		System.out.println(b);								//打印每一个字节   	}



```

```











```
  fis.close();                                          //关闭流释放资源
```



  \###20.03_IO流(read()方法返回值为什么是int)

- read()方法读取的是一个字节,为什么返回是int,而不是byte
- 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111 那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上   	24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型   ###20.04_IO流(FileOutputStream)
- write()一次写出一个字节
- FileOutputStream fos = new FileOutputStream("bbb.txt");	//如果没有bbb.txt,会创建出一个 //fos.write(97);						//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的是一个byte   	fos.write(98);   	fos.write(99);   	fos.close();   ###20.05_IO流(FileOutputStream追加)
- A:案例演示
  - FileOutputStream的构造方法写出数据如何实现数据的追加写入
- FileOutputStream fos = new FileOutputStream("bbb.txt",true);	//如果没有bbb.txt,会创建出一个 //fos.write(97);						//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个byte   	fos.write(98);   	fos.write(99);   	fos.close();

\###20.06_IO流(拷贝图片)

- FileInputStream读取

- FileOutputStream写出

  FileInputStream fis = new FileInputStream("致青春.mp3");	//创建输入流对象,关联致青春.mp3 	FileOutputStream fos = new FileOutputStream("copy.mp3");//创建输出流对象,关联copy.mp3 	



  ```
  
  ```











  ```
  int b;
  ```

  ```
  while((b = fis.read()) != -1) {
  ```

  ```
      fos.write(b);
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  fis.close();
  ```

  ```
  fos.close();
  ```


\###20.07_IO流(拷贝音频文件画原理图)

- A:案例演示
  - 字节流一次读写一个字节复制音频
- 弊端:效率太低

\###20.08_IO流(字节数组拷贝之available()方法)

- A:案例演示

  - int read(byte[] b):一次读取一个字节数组
  - write(byte[] b):一次写出一个字节数组
  - available()获取读的文件所有的字节个数

- 弊端:有可能会内存溢出 

  FileInputStream fis = new FileInputStream("致青春.mp3"); 	FileOutputStream fos = new FileOutputStream("copy.mp3"); 	byte[] arr = new byte[fis.available()];					//根据文件大小做一个字节数组 	fis.read(arr);											//将文件上的所有字节读取到数组中 	fos.write(arr);											//将数组中的所有字节一次写到了文件上 	fis.close(); 	fos.close(); 	

\###20.09_IO流(定义小数组)

- write(byte[] b)

- write(byte[] b, int off, int len)写出有效的字节个数

  	

\###20.10_IO流(定义小数组的标准格式)

- A:案例演示

  - 字节流一次读写一个字节数组复制图片和视频 FileInputStream fis = new FileInputStream("致青春.mp3"); FileOutputStream fos = new FileOutputStream("copy.mp3"); int len; byte[] arr = new byte[1024 * 8];					//自定义字节数组

    while((len = fis.read(arr)) != -1) { 	//fos.write(arr); 	fos.write(arr, 0, len);							//写出字节数组写出有效个字节个数 }

    fis.close(); fos.close(); ###20.11_IO流(BufferedInputStream和BufferOutputStream拷贝)

- A:缓冲思想

  - 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，
  - 这是加入了数组这样的缓冲区效果，java本身在设计的时候，
  - 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流

- B.BufferedInputStream

  - BufferedInputStream内置了一个缓冲区(数组)
  - 从BufferedInputStream中读取一个字节时
  - BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个
  - 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取
  - 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个

- C.BufferedOutputStream

  - BufferedOutputStream也内置了一个缓冲区(数组)
  - 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中
  - 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里

- D.拷贝的代码 

  FileInputStream fis = new FileInputStream("致青春.mp3");			//创建文件输入流对象,关联致青春.mp3 	BufferedInputStream bis = new BufferedInputStream(fis);			//创建缓冲区对fis装饰 	FileOutputStream fos = new FileOutputStream("copy.mp3");		//创建输出流对象,关联copy.mp3 	BufferedOutputStream bos = new BufferedOutputStream(fos);		//创建缓冲区对fos装饰 	



  ```
  
  ```











  ```
  int b;
  ```

  ```
  while((b = bis.read()) != -1) {     
  ```

  ```
      bos.write(b);
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  bis.close();                        //只关装饰后的对象即可
  ```

  ```
  bos.close();
  ```

- E.小数组的读写和带Buffered的读取哪个更快?

  - 定义小数组如果是8192个字节大小和Buffered比较的话
  - 定义小数组会略胜一筹,因为读和写操作的是同一个数组
  - 而Buffered操作的是两个数组

\###20.12_IO流(flush和close方法的区别)

- flush()方法
  - 用来刷新缓冲区的,刷新后可以再次写出 
- close()方法
  - 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出  ###20.13_IO流(字节流读写中文) 
- 字节流读取中文的问题
  - 字节流在读中文的时候有可能会读到半个中文,造成乱码 
- 字节流写出中文的问题
  - 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 
  - 写出回车换行 write("\r\n".getBytes());

\###20.14_IO流(流的标准处理异常代码1.6版本及其以前)

- try finally嵌套

  FileInputStream fis = null; 	FileOutputStream fos = null; 	try { 		fis = new FileInputStream("aaa.txt"); 		fos = new FileOutputStream("bbb.txt"); 		int b; 		while((b = fis.read()) != -1) { 			fos.write(b); 		} 	} finally { 		try { 			if(fis != null) 				fis.close(); 		}finally { 			if(fos != null) 				fos.close(); 		} 	}

\###20.15_IO流(流的标准处理异常代码1.7版本)

- try close

  try( 		FileInputStream fis = new FileInputStream("aaa.txt"); 		FileOutputStream fos = new FileOutputStream("bbb.txt"); 		MyClose mc = new MyClose(); 	){ 		int b; 		while((b = fis.read()) != -1) { 			fos.write(b); 		} 	}

- 原理

  - 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 

\###20.16_IO流(图片加密)

- 给图片加密

  BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.jpg")); 	BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("b.jpg")); 	



  ```
  
  ```











  ```
  int b;
  ```

  ```
  while((b = bis.read()) != -1) {
  ```

  ```
      bos.write(b ^ 123);
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  bis.close();
  ```

  ```
  bos.close();
  ```


\###20.17_IO流(拷贝文件)

- 在控制台录入文件的路径,将文件拷贝到当前项目下

  Scanner sc = new Scanner(System.in); 	System.out.println("请输入一个文件路径"); 	String line = sc.nextLine();				//将键盘录入的文件路径存储在line中 	File file = new File(line);					//封装成File对象 	FileInputStream fis = new FileInputStream(file); 	FileOutputStream fos = new FileOutputStream(file.getName()); 	



  ```
  
  ```











  ```
  int len;
  ```

  ```
  byte[] arr = new byte[8192];                //定义缓冲区
  ```

  ```
  while((len = fis.read(arr)) != -1) {
  ```

  ```
      fos.write(arr,0,len);
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  fis.close();
  ```

  ```
  fos.close();
  ```


\###20.18_IO流(录入数据拷贝到文件)

- 将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出

  Scanner sc = new Scanner(System.in); 	FileOutputStream fos = new FileOutputStream("text.txt"); 	System.out.println("请输入:"); 	while(true) { 		String line = sc.nextLine(); 		if("quit".equals(line)) 			break; 		fos.write(line.getBytes()); 		fos.write("\r\n".getBytes()); 	} 	



  ```
  
  ```











  ```
  fos.close();
  ```



  \###20.19_day20总结

- 把今天的知识点总结一遍。

\###21.01_IO流(字符流FileReader)

- 1.字符流是什么
  - 字符流是可以直接读写字符的IO流
  - 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.    
- 2.FileReader
  - FileReader类的read()方法可以按照字符大小读取
- FileReader fr = new FileReader("aaa.txt");				//创建输入流对象,关联aaa.txt int ch;   	while((ch = fr.read()) != -1) {							//将读到的字符赋值给ch   		System.out.println((char)ch);						//将读到的字符强转后打印   	}



```

```











```
  fr.close();                                               //关流 
```



\###21.02_IO流(字符流FileWriter)

- FileWriter类的write()方法可以自动把字符转为字节写出

  FileWriter fw = new FileWriter("aaa.txt"); 	fw.write("aaa"); 	fw.close();

\###21.03_IO流(字符流的拷贝) 	FileReader fr = new FileReader("a.txt"); 	FileWriter fw = new FileWriter("b.txt"); 	



```

```











```
int ch;
while((ch = fr.read()) != -1) {
    fw.write(ch);
}

fr.close();
fw.close();
```



\###21.04_IO流(什么情况下使用字符流)

- 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.
- 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流
- 读取的时候是按照字符的大小读取的,不会出现半个中文
- 写出的时候可以直接将字符串写出,不用转换为字节数组

\###21.05_IO流(字符流是否可以拷贝非纯文本的文件)

- 不可以拷贝非纯文本的文件
- 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去
- 如果是?,直接写出,这样写出之后的文件就乱了,看不了了  

\###21.06_IO流(自定义字符数组的拷贝)

-   FileReader fr = new FileReader("aaa.txt");			//创建字符输入流,关联aaa.txt   	FileWriter fw = new FileWriter("bbb.txt");			//创建字符输出流,关联bbb.txt



```

```











```
  int len;
  char[] arr = new char[1024*8];                        //创建字符数组
  while((len = fr.read(arr)) != -1) {                   //将数据读到字符数组中
    fw.write(arr, 0, len);                          //从字符数组将数据写到文件上
  }
  
  fr.close();                                           //关流释放资源
  fw.close();   
```



\###21.07_IO流(带缓冲的字符流) 

- BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率
- BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率
- BufferedReader br = new BufferedReader(new FileReader("aaa.txt"));	//创建字符输入流对象,关联aaa.txt BufferedWriter bw = new BufferedWriter(new FileWriter("bbb.txt"));	//创建字符输出流对象,关联bbb.txt



```

```











```
  int ch;               
  while((ch = br.read()) != -1) {       //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch
    bw.write(ch);                   //write一次,是将数据装到字符数组,装满后再一起写出去
  }
  
  br.close();                           //关流
  bw.close();  
```



\###21.08_IO流(readLine()和newLine()方法)	

- BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)
- BufferedWriter的newLine()可以输出一个跨平台的换行符号"\r\n"
- BufferedReader br = new BufferedReader(new FileReader("aaa.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("bbb.txt"));   	String line;   	while((line = br.readLine()) != null) {   		bw.write(line);   		//bw.write("\r\n");					//只支持windows系统   		bw.newLine();						//跨平台的   	}



```

```











```
  br.close();
  bw.close(); 
```



\###21.09_IO流(将文本反转)

- 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换

\###21.10_IO流(LineNumberReader) 

- LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号
  - 调用getLineNumber()方法可以获取当前行号
  - 调用setLineNumber()方法可以设置当前行号
- LineNumberReader lnr = new LineNumberReader(new FileReader("aaa.txt")); String line;   	lnr.setLineNumber(100);									//设置行号   	while((line = lnr.readLine()) != null) {   		System.out.println(lnr.getLineNumber() + ":" + line);//获取行号   	}



```

```











```
  lnr.close(); 
```



\###21.11_IO流(装饰设计模式)

- interface Coder { public void code();   	}



```

```











```
  class Student implements Coder {
  
    @Override
    public void code() {
        System.out.println("javase");
        System.out.println("javaweb");
    }
    
  }
  
  class HeiMaStudent implements Coder {
    private Student s;                      //获取到被包装的类的引用
    public HeiMaStudent(Student s) {        //通过构造函数创建对象的时候,传入被包装的对象
        this.s = s;
    }
    @Override
    public void code() {                    //对其原有功能进行升级
        s.code();
        System.out.println("数据库");
        System.out.println("ssh");
        System.out.println("安卓");
        System.out.println(".....");
    }
    
  } 
```



\###21.12_IO流(使用指定的码表读写字符) 

- FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)
- FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)
- BufferedReader br = 									//高效的用指定的编码表读 new BufferedReader(new InputStreamReader(new FileInputStream("UTF-8.txt"), "UTF-8"));   	BufferedWriter bw = 									//高效的用指定的编码表写   			new BufferedWriter(new OutputStreamWriter(new FileOutputStream("GBK.txt"), "GBK"));   	int ch;   	while((ch = br.read()) != -1) {   		bw.write(ch);   	}



```

```











```
  br.close();
  bw.close();
```



  \###21.13_IO流(转换流图解)

- 画图分析转换流

\###21.14_IO流(获取文本上字符出现的次数)

- 获取一个文本上每个字符出现的次数,将结果写在times.txt上

\###21.15_IO流(试用版软件)

- 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版

\###21.16_File类(递归)

- 5的阶乘	

\###21.17_File类(练习)

- 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名

\###21.18_IO流(总结)

- 1.会用BufferedReader读取GBK码表和UTF-8码表的字符
- 2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中
- 3.会使用BufferedReader从键盘读取一行

﻿###22.01_IO流(序列流)(了解)

- 1.什么是序列流

  - 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.

- 2.使用方式

  - 整合两个: SequenceInputStream(InputStream, InputStream)
  - FileInputStream fis1 = new FileInputStream("a.txt");			//创建输入流对象,关联a.txt FileInputStream fis2 = new FileInputStream("b.txt");			//创建输入流对象,关联b.txt   	SequenceInputStream sis = new SequenceInputStream(fis1, fis2);	//将两个流整合成一个流   	FileOutputStream fos = new FileOutputStream("c.txt");			//创建输出流对象,关联c.txt



  ```
  
  ```











  ```
    int b;
  ```

  ```
    while((b = sis.read()) != -1) {                                   //用整合后的读
  ```

  ```
      fos.write(b);                                               //写到指定文件上
  ```

  ```
    }
  ```

  ```
    
  ```

  ```
    sis.close();
  ```

  ```
    fos.close(); 
  ```



    \###22.02_IO流(序列流整合多个)(了解)

- 整合多个: SequenceInputStream(Enumeration)

- FileInputStream fis1 = new FileInputStream("a.txt");	//创建输入流对象,关联a.txt FileInputStream fis2 = new FileInputStream("b.txt");	//创建输入流对象,关联b.txt   	FileInputStream fis3 = new FileInputStream("c.txt");	//创建输入流对象,关联c.txt   	Vector<InputStream> v = new Vector<>();					//创建vector集合对象   	v.add(fis1);											//将流对象添加   	v.add(fis2);   	v.add(fis3);   	Enumeration<InputStream> en = v.elements();				//获取枚举引用   	SequenceInputStream sis = new SequenceInputStream(en);	//传递给SequenceInputStream构造   	FileOutputStream fos = new FileOutputStream("d.txt");   	int b;   	while((b = sis.read()) != -1) {   		fos.write(b);   	}



```

```











```
  sis.close();
  fos.close();
```



\###22.03_IO流(内存输出流*****)(掌握)

- 1.什么是内存输出流

  - 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据

- 2.使用方式

  - 创建对象: new ByteArrayOutputStream()
  - 写出数据: write(int), write(byte[])
  - 获取数据: toByteArray()
  - FileInputStream fis = new FileInputStream("a.txt"); ByteArrayOutputStream baos = new ByteArrayOutputStream();   	int b;   	while((b = fis.read()) != -1) {   		baos.write(b);   	}



  ```
  
  ```











  ```
    //byte[] newArr = baos.toByteArray();             //将内存缓冲区中所有的字节存储在newArr中
  ```

  ```
    //System.out.println(new String(newArr));
  ```

  ```
    System.out.println(baos);
  ```

  ```
    fis.close();
  ```



    \###22.04_IO流(内存输出流之黑马面试题)(掌握)

- 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)

- FileInputStream fis = new FileInputStream("a.txt");				//创建字节输入流,关联a.txt ByteArrayOutputStream baos = new ByteArrayOutputStream();		//创建内存输出流   		byte[] arr = new byte[5];										//创建字节数组,大小为5   		int len;   		while((len = fis.read(arr)) != -1) {							//将文件上的数据读到字节数组中   			baos.write(arr, 0, len);									//将字节数组的数据写到内存缓冲区中   		}   		System.out.println(baos);										//将内存缓冲区的内容转换为字符串打印   		fis.close();   ###22.05_IO流(随机访问流概述和读写数据)(了解)

- A:随机访问流概述

  - RandomAccessFile概述
  - RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。
  - 支持对随机访问文件的读取和写入。

- B:read(),write(),seek()

\###22.06_IO流(对象操作流ObjecOutputStream)(了解)

- 1.什么是对象操作流

  - 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.

- 2.使用方式

  - 写出: new ObjectOutputStream(OutputStream), writeObject()

    public class Demo3_ObjectOutputStream {



    ```
    
    ```











    ```
        /**
    ```

    ```
         * @param args
    ```

    ```
         * @throws IOException 
    ```

    ```
         * 将对象写出,序列化
    ```

    ```
         */
    ```

    ```
        public static void main(String[] args) throws IOException {
    ```

    ```
            Person p1 = new Person("张三", 23);
    ```

    ```
            Person p2 = new Person("李四", 24);
    ```

    ```
    //      FileOutputStream fos = new FileOutputStream("e.txt");
    ```

    ```
    //      fos.write(p1);
    ```

    ```
    //      FileWriter fw = new FileWriter("e.txt");
    ```

    ```
    //      fw.write(p1);
    ```

    ```
            //无论是字节输出流,还是字符输出流都不能直接写出对象
    ```

    ```
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("e.txt"));//创建对象输出流
    ```

    ```
            oos.writeObject(p1);
    ```

    ```
            oos.writeObject(p2);
    ```

    ```
            oos.close();
    ```

    ```
        }
    ```

    ```
    
    ```

    ```
    }
    ```



    \###22.07_IO流(对象操作流ObjectInputStream)(了解)

- 读取: new ObjectInputStream(InputStream), readObject()

  - public class Demo3_ObjectInputStream {



    ```
    
    ```











    ```
        /**
    ```

    ```
         * @param args
    ```

    ```
         * @throws IOException 
    ```

    ```
         * @throws ClassNotFoundException 
    ```

    ```
         * @throws FileNotFoundException 
    ```

    ```
         * 读取对象,反序列化
    ```

    ```
         */
    ```

    ```
        public static void main(String[] args) throws IOException, ClassNotFoundException {
    ```

    ```
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream("e.txt"));
    ```

    ```
            Person p1 = (Person) ois.readObject();
    ```

    ```
            Person p2 = (Person) ois.readObject();
    ```

    ```
            System.out.println(p1);
    ```

    ```
            System.out.println(p2);
    ```

    ```
            ois.close();
    ```

    ```
        }
    ```

    ```
    
    ```

    ```
    }
    ```


\###22.08_IO流(对象操作流优化)(了解)

- 将对象存储在集合中写出

  Person p1 = new Person("张三", 23); Person p2 = new Person("李四", 24); Person p3 = new Person("马哥", 18); Person p4 = new Person("辉哥", 20);

  ArrayList<Person> list = new ArrayList<>(); list.add(p1); list.add(p2); list.add(p3); list.add(p4);

  ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("f.txt")); oos.writeObject(list);									//写出集合对象

  oos.close();

- 读取到的是一个集合对象

  ObjectInputStream ois = new ObjectInputStream(new FileInputStream("f.txt")); 		ArrayList<Person> list = (ArrayList<Person>)ois.readObject();	//泛型在运行期会被擦除,索引运行期相当于没有泛型 	//想去掉黄色可以加注解			 	@SuppressWarnings("unchecked") 		for (Person person : list) { 			System.out.println(person); 		} 	



  ```
  
  ```











  ```
  ois.close();
  ```



  \###22.09_IO流(加上id号)(了解)

- 注意

  - 要写出的对象必须实现Serializable接口才能被序列化
  - 不用必须加id号

\###22.10_IO流(数据输入输出流)(了解)

- 1.什么是数据输入输出流

  - DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据
  - 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.

- 2.使用方式

  - DataOutputStream(OutputStream), writeInt(), writeLong() 

    DataOutputStream dos = new DataOutputStream(new FileOutputStream("b.txt")); 	dos.writeInt(997); 	dos.writeInt(998); 	dos.writeInt(999); 	



    ```
    
    ```











    ```
    dos.close();
    ```

  - DataInputStream(InputStream), readInt(), readLong()

    DataInputStream dis = new DataInputStream(new FileInputStream("b.txt")); 	int x = dis.readInt(); 	int y = dis.readInt(); 	int z = dis.readInt(); 	System.out.println(x); 	System.out.println(y); 	System.out.println(z); 	dis.close();

\###22.11_IO流(打印流的概述和特点)(掌握)

- 1.什么是打印流

  - 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式

  - System.out就是一个PrintStream, 其默认向控制台输出信息

    PrintStream ps = System.out; 	ps.println(97);					//其实底层用的是Integer.toString(x),将x转换为数字字符串打印 	ps.println("xxx"); 	ps.println(new Person("张三", 23)); 	Person p = null; 	ps.println(p);					//如果是null,就返回null,如果不是null,就调用对象的toString()

- 2.使用方式

  - 打印: print(), println()

  - 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) 

  - 打印流只操作数据目的

    PrintWriter pw = new PrintWriter(new FileOutputStream("g.txt"), true); 	pw.write(97); 	pw.print("大家好"); 	pw.println("你好");				//自动刷出,只针对的是println方法 	pw.close();

\###22.12_IO流(标准输入输出流概述和输出语句)

- 1.什么是标准输入输出流(掌握)

  - System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据
  - System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据

- 2.修改标准输入输出流(了解)

  - 修改输入流: System.setIn(InputStream)
  - 修改输出流: System.setOut(PrintStream)
  - System.setIn(new FileInputStream("a.txt"));				//修改标准输入流 System.setOut(new PrintStream("b.txt"));				//修改标准输出流

  ```
    InputStream in = System.in;								//获取标准输入流
    PrintStream ps = System.out;							//获取标准输出流
    int b;
    while((b = in.read()) != -1) {							//从a.txt上读取数据
    	ps.write(b);										//将数据写到b.txt上
    }
    
    in.close();
    ps.close();
  ```

\###22.13_IO流(修改标准输入输出流拷贝图片)(了解) 		System.setIn(new FileInputStream("IO图片.png"));		//改变标准输入流 		System.setOut(new PrintStream("copy.png")); 		//改变标准输出流 		

```
	InputStream is = System.in;							//获取标准输入流
	PrintStream ps = System.out;						//获取标准输出流
	
	int len;
	byte[] arr = new byte[1024 * 8];
	
	while((len = is.read(arr)) != -1) {
		ps.write(arr, 0, len);
	}
	
	is.close();
	ps.close();
```

\###22.14_IO流(两种方式实现键盘录入)(了解)

- A:BufferedReader的readLine方法。
  - BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
- B:Scanner

\###22.15_IO流(Properties的概述和作为Map集合的使用)(了解)

- A:Properties的概述
  - Properties 类表示了一个持久的属性集。
  - Properties 可保存在流中或从流中加载。
  - 属性列表中每个键及其对应值都是一个字符串。 
- B:案例演示
  - Properties作为Map集合的使用

\###22.16_IO流(Properties的特殊功能使用)(了解)

- A:Properties的特殊功能
  - public Object setProperty(String key,String value)
  - public String getProperty(String key)
  - public Enumeration<String> stringPropertyNames()
- B:案例演示
  - Properties的特殊功能

\###22.17_IO流(Properties的load()和store()功能)(了解)

- A:Properties的load()和store()功能
- B:案例演示
  - Properties的load()和store()功能

\###22.18_day22总结

- 把今天的知识点总结一遍。

\###24.01_多线程(多线程的引入)(了解)

- 1.什么是线程
  - 线程是程序执行的一条路径, 一个进程中可以包含多条线程
  - 多线程并发执行可以提高程序的效率, 可以同时完成多项工作
- 2.多线程的应用场景
  - 红蜘蛛同时共享屏幕给多个电脑
  - 迅雷开启多条线程一起下载
  - QQ同时和多个人一起视频
  - 服务器同时处理多个客户端请求

\###24.02_多线程(多线程并行和并发的区别)(了解)

- 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)
- 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。
- 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。
- 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。

\###24.03_多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)

- A:Java程序运行原理
  - Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。
- B:JVM的启动是多线程的吗
  - JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

\###24.04_多线程(多线程程序实现的方式1)(掌握)

- 1.继承Thread

  - 定义类继承Thread

  - 重写run方法

  - 把新线程要做的事写在run方法中

  - 创建线程对象

  - 开启新线程, 内部会自动执行run方法

  - 

    public class Demo2_Thread {

    ```
    	/**
    	 * @param args
    	 */
    	public static void main(String[] args) {
    		MyThread mt = new MyThread();							//4,创建自定义类的对象
    		mt.start();												//5,开启线程
    		
    		for(int i = 0; i < 3000; i++) {
    			System.out.println("bb");
    		}
    	}
    
    }
    class MyThread extends Thread {									//1,定义类继承Thread
    	public void run() {											//2,重写run方法
    		for(int i = 0; i < 3000; i++) {							//3,将要执行的代码,写在run方法中
    			System.out.println("aaaaaaaaaaaaaaaaaaaaaaaaaaaa");
    		}
    	}
    }
    ```

\###24.05_多线程(多线程程序实现的方式2)(掌握)

- 2.实现Runnable

  - 定义类实现Runnable接口

  - 实现run方法

  - 把新线程要做的事写在run方法中

  - 创建自定义的Runnable的子类对象

  - 创建Thread对象, 传入Runnable

  - 调用start()开启新线程, 内部会自动调用Runnable的run()方法

    public class Demo3_Runnable { 		/** 		 * @param args 		 */ 		public static void main(String[] args) { 			MyRunnable mr = new MyRunnable();						//4,创建自定义类对象 			//Runnable target = new MyRunnable(); 			Thread t = new Thread(mr);								//5,将其当作参数传递给Thread的构造函数 			t.start();												//6,开启线程 			

    ```
    		for(int i = 0; i < 3000; i++) {
    			System.out.println("bb");
    		}
    	}
    }
    
    class MyRunnable implements Runnable {							//1,自定义类实现Runnable接口
    	@Override
    	public void run() {											//2,重写run方法
    		for(int i = 0; i < 3000; i++) {							//3,将要执行的代码,写在run方法中
    			System.out.println("aaaaaaaaaaaaaaaaaaaaaaaaaaaa");
    		}
    	}
    	
    }
    ```

\###24.06_多线程(实现Runnable的原理)(了解)

- 查看源码
  - 1,看Thread类的构造函数,传递了Runnable接口的引用 
  - 2,通过init()方法找到传递的target给成员变量的target赋值
  - 3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法

\###24.07_多线程(两种方式的区别)(掌握)

- 查看源码的区别:
  - a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法
  - b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法
- 继承Thread
  - 好处是:可以直接使用Thread类中的方法,代码简单
  - 弊端是:如果已经有了父类,就不能用这种方法
- 实现Runnable接口
  - 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的
  - 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂 ###24.08_多线程(匿名内部类实现线程的两种方式)(掌握)
- 继承Thread类  	 new Thread() {													//1,new 类(){}继承这个类 		public void run() {											//2,重写run方法 			for(int i = 0; i < 3000; i++) {							//3,将要执行的代码,写在run方法中 				System.out.println("aaaaaaaaaaaaaaaaaaaaaaaaaaaa"); 			} 		} 	}.start();
- 实现Runnable接口 		 new Thread(new Runnable(){										//1,new 接口(){}实现这个接口 		public void run() {											//2,重写run方法 			for(int i = 0; i < 3000; i++) {							//3,将要执行的代码,写在run方法中 				System.out.println("bb"); 			} 		} 	}).start(); 

\###24.09_多线程(获取名字和设置名字)(掌握)

- 1.获取名字

  - 通过getName()方法获取线程对象的名字

- 2.设置名字

  - 通过构造函数可以传入String类型的名字
  - new Thread("xxx") { public void run() {   			for(int i = 0; i < 1000; i++) {   				System.out.println(this.getName() + "....aaaaaaaaaaaaaaaaaaaaaaa");   			}   		}   	}.start();

  ```
    new Thread("yyy") {
    	public void run() {
    		for(int i = 0; i < 1000; i++) {
    			System.out.println(this.getName() + "....bb");
    		}
    	}
    }.start(); 
  ```

  - 通过setName(String)方法可以设置线程对象的名字
  - Thread t1 = new Thread() { public void run() {   			for(int i = 0; i < 1000; i++) {   				System.out.println(this.getName() + "....aaaaaaaaaaaaaaaaaaaaaaa");   			}   		}   	};

  ```
    Thread t2 = new Thread() {
    	public void run() {
    		for(int i = 0; i < 1000; i++) {
    			System.out.println(this.getName() + "....bb");
    		}
    	}
    };
    t1.setName("芙蓉姐姐");
    t2.setName("凤姐");
    
    t1.start();
    t2.start();
  ```

\###24.10_多线程(获取当前线程的对象)(掌握)

- Thread.currentThread(), 主线程也可以获取

  - new Thread(new Runnable() { public void run() {   			for(int i = 0; i < 1000; i++) {   				System.out.println(Thread.currentThread().getName() + "...aaaaaaaaaaaaaaaaaaaaa");   			}   		}   	}).start();

  ```
    new Thread(new Runnable() {
    	public void run() {
    		for(int i = 0; i < 1000; i++) {
    			System.out.println(Thread.currentThread().getName() + "...bb");
    		}
    	}
    }).start();
    Thread.currentThread().setName("我是主线程");					//获取主函数线程的引用,并改名字
    System.out.println(Thread.currentThread().getName());		//获取主函数线程的引用,并获取名字
  ```

    \###24.11_多线程(休眠线程)(掌握)

- Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 * 1000 * 1000纳秒 1000000000

  new Thread() { 			public void run() { 				for(int i = 0; i < 10; i++) { 					System.out.println(getName() + "...aaaaaaaaaaaaaaaaaaaaaa"); 					try { 						Thread.sleep(10); 					} catch (InterruptedException e) { 						e.printStackTrace(); 					} 				} 			} 		}.start(); 		

  ```
  	new Thread() {
  		public void run() {
  			for(int i = 0; i < 10; i++) {
  				System.out.println(getName() + "...bb");
  				try {
  					Thread.sleep(10);
  				} catch (InterruptedException e) {
  					e.printStackTrace();
  				}
  			}
  		}
  	}.start();
  ```

  \###24.12_多线程(守护线程)(掌握)

- setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出

  - Thread t1 = new Thread() { public void run() {   			for(int i = 0; i < 50; i++) {   				System.out.println(getName() + "...aaaaaaaaaaaaaaaaaaaaaa");   				try {   					Thread.sleep(10);   				} catch (InterruptedException e) {   					e.printStackTrace();   				}   			}   		}   	};

  ```
    Thread t2 = new Thread() {
    	public void run() {
    		for(int i = 0; i < 5; i++) {
    			System.out.println(getName() + "...bb");
    			try {
    				Thread.sleep(10);
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    	}
    };
    
    t1.setDaemon(true);						//将t1设置为守护线程
    
    t1.start();
    t2.start();
  ```

    \###24.13_多线程(加入线程)(掌握)

- join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续

- join(int), 可以等待指定的毫秒之后继续

  - final Thread t1 = new Thread() { public void run() {   			for(int i = 0; i < 50; i++) {   				System.out.println(getName() + "...aaaaaaaaaaaaaaaaaaaaaa");   				try {   					Thread.sleep(10);   				} catch (InterruptedException e) {   					e.printStackTrace();   				}   			}   		}   	};

  ```
    Thread t2 = new Thread() {
    	public void run() {
    		for(int i = 0; i < 50; i++) {
    			if(i == 2) {
    				try {
    					//t1.join();						//插队,加入
    					t1.join(30);						//加入,有固定的时间,过了固定时间,继续交替执行
    					Thread.sleep(10);
    				} catch (InterruptedException e) {
    					
    					e.printStackTrace();
    				}
    			}
    			System.out.println(getName() + "...bb");
    		
    		}
    	}
    };
    
    t1.start();
    t2.start();
  ```

    \###24.14_多线程(礼让线程)(了解)

- yield让出cpu

\###24.15_多线程(设置线程的优先级)(了解)

- setPriority()设置线程的优先级

\###24.16_多线程(同步代码块)(掌握)

- 1.什么情况下需要同步

  - 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.
  - 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.

- 2.同步代码块

  - 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块

  - 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的

    class Printer { 		Demo d = new Demo(); 		public static void print1() { 			synchronized(d){				//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 				System.out.print("黑"); 				System.out.print("马"); 				System.out.print("程"); 				System.out.print("序"); 				System.out.print("员"); 				System.out.print("\r\n"); 			} 		}

    ```
    	public static void print2() {	
    		synchronized(d){	
    			System.out.print("传");
    			System.out.print("智");
    			System.out.print("播");
    			System.out.print("客");
    			System.out.print("\r\n");
    		}
    	}
    }
    ```

    \###24.17_多线程(同步方法)(掌握)

- 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的

  class Printer { 		public static void print1() { 			synchronized(Printer.class){				//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 				System.out.print("黑"); 				System.out.print("马"); 				System.out.print("程"); 				System.out.print("序"); 				System.out.print("员"); 				System.out.print("\r\n"); 			} 		} 		/* 		 * 非静态同步函数的锁是:this 		 * 静态的同步函数的锁是:字节码对象 		 */ 		public static synchronized void print2() {	 			System.out.print("传"); 			System.out.print("智"); 			System.out.print("播"); 			System.out.print("客"); 			System.out.print("\r\n"); 		} 	}

\###24.18_多线程(线程安全问题)(掌握)

- 多线程并发操作同一数据时, 就有可能出现线程安全问题

- 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作 		 public class Demo2_Synchronized {

  ```
  		/**
  		 * @param args
  		 * 需求:铁路售票,一共100张,通过四个窗口卖完.
  		 */
  		public static void main(String[] args) {
  			TicketsSeller t1 = new TicketsSeller();
  			TicketsSeller t2 = new TicketsSeller();
  			TicketsSeller t3 = new TicketsSeller();
  			TicketsSeller t4 = new TicketsSeller();
  			
  			t1.setName("窗口1");
  			t2.setName("窗口2");
  			t3.setName("窗口3");
  			t4.setName("窗口4");
  			t1.start();
  			t2.start();
  			t3.start();
  			t4.start();
  		}
  	
  	}
  	
  	class TicketsSeller extends Thread {
  		private static int tickets = 100;
  		static Object obj = new Object();
  		public TicketsSeller() {
  			super();
  			
  		}
  		public TicketsSeller(String name) {
  			super(name);
  		}
  		public void run() {
  			while(true) {
  				synchronized(obj) {
  					if(tickets <= 0) 
  						break;
  					try {
  						Thread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡
  					} catch (InterruptedException e) {
  						
  						e.printStackTrace();
  					}
  					System.out.println(getName() + "...这是第" + tickets-- + "号票");
  				}
  			}
  		}
  	}
  ```

\###24.19_多线程(火车站卖票的例子用实现Runnable接口)(掌握)

\###24.20_多线程(死锁)(了解)

- 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁

  - 尽量不要嵌套使用

    private static String s1 = "筷子左"; 	private static String s2 = "筷子右"; 	public static void main(String[] args) { 		new Thread() { 			public void run() { 				while(true) { 					synchronized(s1) { 						System.out.println(getName() + "...拿到" + s1 + "等待" + s2); 						synchronized(s2) { 							System.out.println(getName() + "...拿到" + s2 + "开吃"); 						} 					} 				} 			} 		}.start(); 		

    ```
    	new Thread() {
    		public void run() {
    			while(true) {
    				synchronized(s2) {
    					System.out.println(getName() + "...拿到" + s2 + "等待" + s1);
    					synchronized(s1) {
    						System.out.println(getName() + "...拿到" + s1 + "开吃");
    					}
    				}
    			}
    		}
    	}.start();
    }
    ```

\###24.21_多线程(以前的线程安全的类回顾)(掌握)

- A:回顾以前说过的线程安全问题
  - 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)
  - Vector是线程安全的,ArrayList是线程不安全的
  - StringBuffer是线程安全的,StringBuilder是线程不安全的
  - Hashtable是线程安全的,HashMap是线程不安全的 ###24.22_多线程(总结)	

\###25.01_多线程(单例设计模式)(掌握)

- 单例设计模式：保证类在内存中只有一个对象。

- 如何保证类在内存中只有一个对象呢？

  - (1)控制类的创建，不让其他类来创建本类的对象。private
  - (2)在本类中定义一个本类的对象。Singleton s;
  - (3)提供公共的访问方式。  public static Singleton getInstance(){return s}

- 单例写法两种：

  - (1)饿汉式 开发用这种方式。
  - //饿汉式 class Singleton {   		//1,私有构造函数   		private Singleton(){}   		//2,创建本类对象   		private static Singleton s = new Singleton();   		//3,对外提供公共的访问方法   		public static Singleton getInstance() {   			return s;   		}

  ```
    	public static void print() {
    		System.out.println("11111111111");
    	}
    }
  ```

  - (2)懒汉式 面试写这种方式。多线程的问题？
  - //懒汉式,单例的延迟加载模式 class Singleton {   		//1,私有构造函数   		private Singleton(){}   		//2,声明一个本类的引用   		private static Singleton s;   		//3,对外提供公共的访问方法   		public static Singleton getInstance() {   			if(s == null)   				//线程1,线程2   				s = new Singleton();   			return s;   		}

  ```
    	public static void print() {
    		System.out.println("11111111111");
    	}
    }
  ```

  - (3)第三种格式
  - class Singleton { private Singleton() {}

  ```
    	public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改
    }
  ```

    \###25.02_多线程(Runtime类)

- Runtime类是一个单例类

  - Runtime r = Runtime.getRuntime(); //r.exec("shutdown -s -t 300");		//300秒后关机   	r.exec("shutdown -a");				//取消关机

\###25.03_多线程(Timer)(掌握)

- Timer类:计时器

  public class Demo5_Timer { 			/** 			 * @param args 			 * 计时器 			 * @throws InterruptedException  			 */ 			public static void main(String[] args) throws InterruptedException { 				Timer t = new Timer(); 				t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000); 				

  ```
  			while(true) {
  				System.out.println(new Date());
  				Thread.sleep(1000);
  			}
  		}
  	}
  	class MyTimerTask extends TimerTask {
  		@Override
  		public void run() {
  			System.out.println("起床背英语单词");
  		}
  		
  	}
  ```

\###25.04_多线程(两个线程间的通信)(掌握)

- 1.什么时候需要通信
  - 多个线程并发执行时, 在默认情况下CPU是随机切换线程的
  - 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印
- 2.怎么通信
  - 如果希望线程等待, 就调用wait()
  - 如果希望唤醒等待的线程, 就调用notify();
  - 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用

\###25.05_多线程(三个或三个以上间的线程通信)

- 多个线程通信的问题
  - notify()方法是随机唤醒一个线程
  - notifyAll()方法是唤醒所有线程
  - JDK5之前无法唤醒指定的一个线程
  - 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件 ###25.06_多线程(JDK1.5的新特性互斥锁)(掌握)
- 1.同步
  - 使用ReentrantLock类的lock()和unlock()方法进行同步
- 2.通信
  - 使用ReentrantLock类的newCondition()方法可以获取Condition对象
  - 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法
  - 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了

\###25.07_多线程(线程组的概述和使用)(了解)

- A:线程组概述

  - Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。
  - 默认情况下，所有的线程都属于主线程组。
    - public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组
    - public final String getName()//通过线程组对象获取他组的名字
  - 我们也可以给线程设置分组
    - 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字
    - 2,创建线程对象
    - 3,Thread(ThreadGroup?group, Runnable?target, String?name) 
    - 4,设置整组的优先级或者守护线程
  - B:案例演示
    - 线程组的使用,默认是主线程组

- MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr, "张三");   	Thread t2 = new Thread(mr, "李四");   	//获取线程组   	// 线程类里面的方法：public final ThreadGroup getThreadGroup()   	ThreadGroup tg1 = t1.getThreadGroup();   	ThreadGroup tg2 = t2.getThreadGroup();   	// 线程组里面的方法：public final String getName()   	String name1 = tg1.getName();   	String name2 = tg2.getName();   	System.out.println(name1);   	System.out.println(name2);   	// 通过结果我们知道了：线程默认情况下属于main线程组   	// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组   	System.out.println(Thread.currentThread().getThreadGroup().getName());

- 自己设定线程组

- ```
  // ThreadGroup(String name)
  ThreadGroup tg = new ThreadGroup("这是一个新的组");
  
  MyRunnable mr = new MyRunnable();
  // Thread(ThreadGroup group, Runnable target, String name)
  Thread t1 = new Thread(tg, mr, "张三");
  Thread t2 = new Thread(tg, mr, "李四");
  
  System.out.println(t1.getThreadGroup().getName());
  System.out.println(t2.getThreadGroup().getName());
  
  //通过组名称设置后台线程，表示该组的线程都是后台线程
  tg.setDaemon(true);
  ```

  \###25.08_多线程(线程的五种状态)(掌握)

- 看图说话

- 新建,就绪,运行,阻塞,死亡

\###25.09_多线程(线程池的概述和使用)(了解)

- A:线程池概述
  - 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池
- B:内置线程池的使用概述
  - JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法
    - public static ExecutorService newFixedThreadPool(int nThreads)
    - public static ExecutorService newSingleThreadExecutor()
    - 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法
    - Future<?> submit(Runnable task)
    - <T> Future<T> submit(Callable<T> task)
  - 使用步骤：
    - 创建线程池对象
    - 创建Runnable实例
    - 提交Runnable实例
    - 关闭线程池
  - C:案例演示
    - 提交的是Runnable
- // public static ExecutorService newFixedThreadPool(int nThreads) ExecutorService pool = Executors.newFixedThreadPool(2);

```
  // 可以执行Runnable对象或者Callable对象代表的线程
  pool.submit(new MyRunnable());
  pool.submit(new MyRunnable());
  
  //结束线程池
  pool.shutdown();
```

\###25.10_多线程(多线程程序实现的方式3)(了解)

- 提交的是Callable
- // 创建线程池对象 ExecutorService pool = Executors.newFixedThreadPool(2);

```
  // 可以执行Runnable对象或者Callable对象代表的线程
  Future<Integer> f1 = pool.submit(new MyCallable(100));
  Future<Integer> f2 = pool.submit(new MyCallable(200));
  
  // V get()
  Integer i1 = f1.get();
  Integer i2 = f2.get();
  
  System.out.println(i1);
  System.out.println(i2);
  
  // 结束
  pool.shutdown();
  
  public class MyCallable implements Callable<Integer> {
  
  	private int number;
  
  	public MyCallable(int number) {
  		this.number = number;
  	}
  
  	@Override
  	public Integer call() throws Exception {
  		int sum = 0;
  		for (int x = 1; x <= number; x++) {
  			sum += x;
  		}
  		return sum;
  	}
  
  }
```

- 多线程程序实现的方式3的好处和弊端
  - 好处：
    - 可以有返回值
    - 可以抛出异常
  - 弊端：
    - 代码比较复杂，所以一般不用

\###25.11_设计模式(简单工厂模式概述和使用)(了解)

- A:简单工厂模式概述
  - 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例
- B:优点
  - 客户端不需要在负责对象的创建，从而明确了各个类的职责
- C:缺点
  - 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护
- D:案例演示
  - 动物抽象类：public abstract Animal { public abstract void eat(); }
  - 具体狗类：public class Dog extends Animal {}
  - 具体猫类：public class Cat extends Animal {}
  - 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。
- public class AnimalFactory { private AnimalFactory(){}

```
  	//public static Dog createDog() {return new Dog();}
  	//public static Cat createCat() {return new Cat();}
  
  	//改进
  	public static Animal createAnimal(String animalName) {
  		if(“dog”.equals(animalName)) {}
  		else if(“cat”.equals(animale)) {
  
  		}else {
  			return null;
  		}
  	}
  } 
```

  \###25.12_设计模式(工厂方法模式的概述和使用)(了解)

- A:工厂方法模式概述
  - 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。
- B:优点
  - 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性
- C:缺点
  - 需要额外的编写代码，增加了工作量
- D:案例演示
- 动物抽象类：public abstract Animal { public abstract void eat(); } 工厂接口：public interface Factory {public abstract Animal createAnimal();}   	具体狗类：public class Dog extends Animal {}   	具体猫类：public class Cat extends Animal {}   	开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。   	狗工厂：public class DogFactory implements Factory {   		public Animal createAnimal() {…}   	        }   	猫工厂：public class CatFactory implements Factory {   		public Animal createAnimal() {…}   	        }  

\###25.13_GUI(如何创建一个窗口并显示)

- Graphical User Interface(图形用户接口)。
- Frame  f = new Frame(“my window”); f.setLayout(new FlowLayout());//设置布局管理器   	f.setSize(500,400);//设置窗体大小   	f.setLocation(300,200);//设置窗体出现在屏幕的位置   	f.setIconImage(Toolkit.getDefaultToolkit().createImage("qq.png"));   	f.setVisible(true);

\###25.14_GUI(布局管理器)

- FlowLayout（流式布局管理器）
  - 从左到右的顺序排列。
  - Panel默认的布局管理器。
- BorderLayout（边界布局管理器）
  - 东，南，西，北，中
  - Frame默认的布局管理器。
- GridLayout（网格布局管理器）
  - 规则的矩阵
- CardLayout（卡片布局管理器）
  - 选项卡
- GridBagLayout（网格包布局管理器）
  - 非规则的矩阵 ###25.15_GUI(窗体监听) Frame f = new Frame("我的窗体"); //事件源是窗体,把监听器注册到事件源上 //事件对象传递给监听器 f.addWindowListener(new WindowAdapter() {         public void windowClosing(WindowEvent e) {                    //退出虚拟机,关闭窗口 	System.exit(0); } });

\###25.16_GUI(鼠标监听) ###25.17_GUI(键盘监听和键盘事件) ###25.18_GUI(动作监听) ###25.19_设计模式(适配器设计模式)(掌握)

- a.什么是适配器
  - 在使用监听器的时候, 需要定义一个类事件监听器接口.
  - 通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.
  - 适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.
- b.适配器原理
  - 适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.
  - 适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的
  - 目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了. ###25.20_GUI(需要知道的) 
- 事件处理
  - 事件: 用户的一个操作
  - 事件源: 被操作的组件
  - 监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法 ###25.21_day25总结 把今天的知识点总结一遍。

day26授课目录：

\###26.01_网络编程(网络编程概述)(了解)

- A:计算机网络
  - 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
- B:网络编程
  - 就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。

\###26.02_网络编程(网络编程三要素之IP概述)(掌握)

- 每个设备在网络中的唯一标识
- 每台网络终端在网络中都有一个独立的地址，我们在网络中传输数据就是使用这个地址。 
- ipconfig：查看本机IP192.168.12.42
- ping：测试连接192.168.40.62
- 本地回路地址：127.0.0.1 255.255.255.255是广播地址
- IPv4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。 
- IPv6：8组，每组4个16进制数。
- 1a2b:0000:aaaa:0000:0000:0000:aabb:1f2f
- 1a2b::aaaa:0000:0000:0000:aabb:1f2f
- 1a2b:0000:aaaa::aabb:1f2f
- 1a2b:0000:aaaa::0000:aabb:1f2f
- 1a2b:0000:aaaa:0000::aabb:1f2f

\###26.03_网络编程(网络编程三要素之端口号概述)(掌握)

- 每个程序在设备上的唯一标识
- 每个网络程序都需要绑定一个端口号，传输数据的时候除了确定发到哪台机器上，还要明确发到哪个程序。
- 端口号范围从0-65535
- 编写网络应用就需要绑定一个端口号，尽量使用1024以上的，1024以下的基本上都被系统程序占用了。
- 常用端口
  - mysql: 3306
  - oracle: 1521
  - web: 80
  - tomcat: 8080
  - QQ: 4000
  - feiQ: 2425

\###26.04_网络编程(网络编程三要素协议)(掌握)

- 为计算机网络中进行数据交换而建立的规则、标准或约定的集合。
- UDP
  - 面向无连接，数据不安全，速度快。不区分客户端与服务端。
- TCP
- 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。
  - 三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据

\###26.05_网络编程(Socket通信原理图解)(了解)

- A:Socket套接字概述：
  - 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。
  - 通信的两端都有Socket。
  - 网络通信其实就是Socket间的通信。
  - 数据在两个Socket间通过IO流传输。
  - Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。

\###26.06_网络编程(UDP传输)(了解)

- 1.发送Send
  - 创建DatagramSocket, 随机端口号
  - 创建DatagramPacket, 指定数据, 长度, 地址, 端口
  - 使用DatagramSocket发送DatagramPacket
  - 关闭DatagramSocket
- 2.接收Receive
  - 创建DatagramSocket, 指定端口号
  - 创建DatagramPacket, 指定数组, 长度
  - 使用DatagramSocket接收DatagramPacket
  - 关闭DatagramSocket
  - 从DatagramPacket中获取数据
- 3.接收方获取ip和端口号
  - String ip = packet.getAddress().getHostAddress();
  - int port = packet.getPort();

\###26.07_网络编程(UDP传输优化)

- 接收端Receive
- DatagramSocket socket = new DatagramSocket(6666);						//创建socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);		//创建packet相当于创建集装箱

```
  while(true) {
  	socket.receive(packet);												//接收货物
  	byte[] arr = packet.getData();
  	int len = packet.getLength();
  	String ip = packet.getAddress().getHostAddress();
  	System.out.println(ip + ":" + new String(arr,0,len));
  }
```

- 发送端Send

  DatagramSocket socket = new DatagramSocket();		//创建socket相当于创建码头 	Scanner sc = new Scanner(System.in); 	

  ```
  while(true) {
  	String str = sc.nextLine();
  	if("quit".equals(str))
  		break;
  	DatagramPacket packet = 							//创建packet相当于创建集装箱
  			new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName("127.0.0.1"), 6666);
  	socket.send(packet);			//发货
  }
  socket.close();
  ```

  \###26.08_网络编程(UDP传输多线程)

- A发送和接收在一个窗口完成

  public class Demo3_MoreThread {

  ```
  	/**
  	 * @param args
  	 */
  	public static void main(String[] args) {
  		new Receive().start();
  		
  		new Send().start();
  	}
  
  }
  
  class Receive extends Thread {
  	public void run() {
  		try {
  			DatagramSocket socket = new DatagramSocket(6666);					//创建socket相当于创建码头
  			DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);	//创建packet相当于创建集装箱
  			
  			while(true) {
  				socket.receive(packet);												//接收货物
  				byte[] arr = packet.getData();
  				int len = packet.getLength();
  				String ip = packet.getAddress().getHostAddress();
  				System.out.println(ip + ":" + new String(arr,0,len));
  			}
  		} catch (IOException e) {
  			
  			e.printStackTrace();
  		}
  	}
  }
  
  class Send extends Thread {
  	public void run() {
  		try {
  			DatagramSocket socket = new DatagramSocket();		//创建socket相当于创建码头
  			Scanner sc = new Scanner(System.in);
  			
  			while(true) {
  				String str = sc.nextLine();
  				if("quit".equals(str))
  					break;
  				DatagramPacket packet = 							//创建packet相当于创建集装箱
  						new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName("127.0.0.1"), 6666);
  				socket.send(packet);			//发货
  			}
  			socket.close();
  		}  catch (IOException e) {
  			
  			e.printStackTrace();
  		}
  	}
  }
  ```

\###26.09_网络编程(UDP聊天图形化界面) 	

\###26.10*网络编程(UDP聊天发送功能) 	 		 ###26.11*网络编程(UDP聊天记录功能) 	 	 ###26.12_网络编程(UDP聊天清屏功能)

\###26.13_网络编程(UDP聊天震动功能)

\###26.14_网络编程(UDP聊天快捷键和代码优化) 	

\###26.15_网络编程(UDP聊天生成jar文件)

\###26.16_网络编程(TCP协议)(掌握)

- 1.客户端
  - 创建Socket连接服务端(指定ip地址,端口号)通过ip地址找对应的服务器
  - 调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的IO流
  - 输入流可以读取服务端输出流写出的数据
  - 输出流可以写出数据到服务端的输入流
- 2.服务端
  - 创建ServerSocket(需要指定端口号)
  - 调用ServerSocket的accept()方法接收一个客户端请求，得到一个Socket
  - 调用Socket的getInputStream()和getOutputStream()方法获取和客户端相连的IO流
  - 输入流可以读取客户端输出流写出的数据
  - 输出流可以写出数据到客户端的输入流

\###26.17_网络编程(TCP协议代码优化)

- 客户端

  Socket socket = new Socket("127.0.0.1", 9999);		//创建Socket指定ip地址和端口号 	InputStream is = socket.getInputStream();			//获取输入流 	OutputStream os = socket.getOutputStream();			//获取输出流 	BufferedReader br = new BufferedReader(new InputStreamReader(is)); 	PrintStream ps = new PrintStream(os); 	

  ```
  System.out.println(br.readLine());
  ps.println("我想报名就业班");
  System.out.println(br.readLine());
  ps.println("爷不学了");
  socket.close();
  ```

- 服务端

  ServerSocket server = new ServerSocket(9999);	//创建服务器 	Socket socket = server.accept();				//接受客户端的请求 	InputStream is = socket.getInputStream();		//获取输入流 	OutputStream os = socket.getOutputStream();		//获取输出流 	

  ```
  BufferedReader br = new BufferedReader(new InputStreamReader(is));
  PrintStream ps = new PrintStream(os);
  
  ps.println("欢迎咨询传智播客");
  System.out.println(br.readLine());
  ps.println("报满了,请报下一期吧");
  System.out.println(br.readLine());
  server.close();
  socket.close();
  ```

\###26.18_网络编程(服务端是多线程的)(掌握) 	ServerSocket server = new ServerSocket(9999);	//创建服务器 		while(true) { 			final Socket socket = server.accept();				//接受客户端的请求 			new Thread() { 				public void run() { 					try { 						BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); 						PrintStream ps = new PrintStream(socket.getOutputStream()); 						ps.println("欢迎咨询传智播客"); 						System.out.println(br.readLine()); 						ps.println("报满了,请报下一期吧"); 						System.out.println(br.readLine()); 						socket.close(); 					} catch (IOException e) { 						e.printStackTrace(); 					} 				} 			}.start(); 		} 	}

\###26.19_网络编程(练习)

- 客户端向服务器写字符串(键盘录入),服务器(多线程)将字符串反转后写回,客户端再次读取到是反转后的字符串 ###26.20_网络编程(练习)
- 客户端向服务器上传文件 ###26.21_day26总结
- 把今天的知识点总结一遍。